{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = jasmineAsyncInstall;\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _throat = _interopRequireDefault(require('throat'));\n\nvar _isError = _interopRequireDefault(require('./isError'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n\nconst doneFnNoop = () => {};\n\ndoneFnNoop.fail = () => {};\n\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      return originalFn.call(env);\n    }\n\n    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n\n    const asyncJestLifecycle = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn) ? _co.default.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {\n            isError: checkIsError,\n            message\n          } = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n} // Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\n\n\nfunction promisifyIt(originalFn, env, jasmine) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack;\n\n    const asyncJestTest = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn) ? _co.default.wrap(fn) : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {\n            isError: checkIsError,\n            message\n          } = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(new Error('Jest: `it` and `test` must return either a Promise or undefined.'));\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(originalFn, env, mutex) {\n  const concurrentFn = function (specName, fn, timeout) {\n    let promise = Promise.resolve();\n    const spec = originalFn.call(env, specName, () => promise, timeout);\n\n    if (env != null && !env.specFilter(spec)) {\n      return spec;\n    }\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n\n        if (isPromise(promise)) {\n          return promise;\n        }\n\n        throw new Error(`Jest: concurrent test \"${spec.getFullName()}\" must return a Promise.`);\n      });\n    } catch (error) {\n      promise = Promise.reject(error);\n    }\n\n    return spec;\n  }; // each is binded after the function is made concurrent, so for now it is made noop\n\n\n  concurrentFn.each = () => () => {};\n\n  return concurrentFn;\n}\n\nfunction jasmineAsyncInstall(globalConfig, global) {\n  const jasmine = global.jasmine;\n  const mutex = (0, _throat.default)(globalConfig.maxConcurrency);\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(env.it, env, mutex);\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js"],"names":["Object","defineProperty","exports","value","default","jasmineAsyncInstall","_co","_interopRequireDefault","require","_isGeneratorFn","_throat","_isError","obj","__esModule","Symbol","global","Promise","for","isPromise","then","doneFnNoop","fail","promisifyLifeCycleFunction","originalFn","env","fn","timeout","call","hasDoneCallback","length","extraError","Error","stack","asyncJestLifecycle","done","wrappedFn","wrap","returnValue","bind","error","isError","checkIsError","message","promisifyIt","jasmine","specName","spec","pend","asyncJestTest","Spec","isPendingSpecException","pending","undefined","makeConcurrent","mutex","concurrentFn","promise","resolve","specFilter","getFullName","reject","each","globalConfig","maxConcurrency","getEnv","it","fit","concurrent","only","skip","xit","afterAll","afterEach","beforeAll","beforeEach"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = jasmineAsyncInstall;\n\nvar _co = _interopRequireDefault(require('co'));\n\nvar _isGeneratorFn = _interopRequireDefault(require('is-generator-fn'));\n\nvar _throat = _interopRequireDefault(require('throat'));\n\nvar _isError = _interopRequireDefault(require('./isError'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction isPromise(obj) {\n  return obj && typeof obj.then === 'function';\n}\n\nconst doneFnNoop = () => {};\n\ndoneFnNoop.fail = () => {};\n\nfunction promisifyLifeCycleFunction(originalFn, env) {\n  return function (fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      return originalFn.call(env);\n    }\n\n    const hasDoneCallback = typeof fn === 'function' && fn.length > 0;\n\n    if (hasDoneCallback) {\n      // Jasmine will handle it\n      return originalFn.call(env, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack; // We make *all* functions async and run `done` right away if they\n    // didn't return a promise.\n\n    const asyncJestLifecycle = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          done.fail(checkIsError ? error : extraError);\n        });\n      } else {\n        done();\n      }\n    };\n\n    return originalFn.call(env, asyncJestLifecycle, timeout);\n  };\n} // Similar to promisifyLifeCycleFunction but throws an error\n// when the return value is neither a Promise nor `undefined`\n\nfunction promisifyIt(originalFn, env, jasmine) {\n  return function (specName, fn, timeout) {\n    if (!fn) {\n      // @ts-expect-error: missing fn arg is handled by originalFn\n      const spec = originalFn.call(env, specName);\n      spec.pend('not implemented');\n      return spec;\n    }\n\n    const hasDoneCallback = fn.length > 0;\n\n    if (hasDoneCallback) {\n      return originalFn.call(env, specName, fn, timeout);\n    }\n\n    const extraError = new Error(); // Without this line v8 stores references to all closures\n    // in the stack in the Error object. This line stringifies the stack\n    // property to allow garbage-collecting objects on the stack\n    // https://crbug.com/v8/7142\n\n    extraError.stack = extraError.stack;\n\n    const asyncJestTest = function (done) {\n      const wrappedFn = (0, _isGeneratorFn.default)(fn)\n        ? _co.default.wrap(fn)\n        : fn;\n      const returnValue = wrappedFn.call({}, doneFnNoop);\n\n      if (isPromise(returnValue)) {\n        returnValue.then(done.bind(null, null), error => {\n          const {isError: checkIsError, message} = (0, _isError.default)(error);\n\n          if (message) {\n            extraError.message = message;\n          }\n\n          if (jasmine.Spec.isPendingSpecException(error)) {\n            env.pending(message);\n            done();\n          } else {\n            done.fail(checkIsError ? error : extraError);\n          }\n        });\n      } else if (returnValue === undefined) {\n        done();\n      } else {\n        done.fail(\n          new Error(\n            'Jest: `it` and `test` must return either a Promise or undefined.'\n          )\n        );\n      }\n    };\n\n    return originalFn.call(env, specName, asyncJestTest, timeout);\n  };\n}\n\nfunction makeConcurrent(originalFn, env, mutex) {\n  const concurrentFn = function (specName, fn, timeout) {\n    let promise = Promise.resolve();\n    const spec = originalFn.call(env, specName, () => promise, timeout);\n\n    if (env != null && !env.specFilter(spec)) {\n      return spec;\n    }\n\n    try {\n      promise = mutex(() => {\n        const promise = fn();\n\n        if (isPromise(promise)) {\n          return promise;\n        }\n\n        throw new Error(\n          `Jest: concurrent test \"${spec.getFullName()}\" must return a Promise.`\n        );\n      });\n    } catch (error) {\n      promise = Promise.reject(error);\n    }\n\n    return spec;\n  }; // each is binded after the function is made concurrent, so for now it is made noop\n\n  concurrentFn.each = () => () => {};\n\n  return concurrentFn;\n}\n\nfunction jasmineAsyncInstall(globalConfig, global) {\n  const jasmine = global.jasmine;\n  const mutex = (0, _throat.default)(globalConfig.maxConcurrency);\n  const env = jasmine.getEnv();\n  env.it = promisifyIt(env.it, env, jasmine);\n  env.fit = promisifyIt(env.fit, env, jasmine);\n\n  global.it.concurrent = (env => {\n    const concurrent = makeConcurrent(env.it, env, mutex);\n    concurrent.only = makeConcurrent(env.fit, env, mutex);\n    concurrent.skip = makeConcurrent(env.xit, env, mutex);\n    return concurrent;\n  })(env);\n\n  global.fit.concurrent = makeConcurrent(env.fit, env, mutex);\n  env.afterAll = promisifyLifeCycleFunction(env.afterAll, env);\n  env.afterEach = promisifyLifeCycleFunction(env.afterEach, env);\n  env.beforeAll = promisifyLifeCycleFunction(env.beforeAll, env);\n  env.beforeEach = promisifyLifeCycleFunction(env.beforeEach, env);\n}\n"]},"metadata":{},"sourceType":"script"}