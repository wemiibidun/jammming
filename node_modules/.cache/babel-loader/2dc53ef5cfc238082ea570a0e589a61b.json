{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = queueRunner;\n\nvar _jestUtil = require('jest-util');\n\nvar _PCancelable = _interopRequireDefault(require('./PCancelable'));\n\nvar _pTimeout = _interopRequireDefault(require('./pTimeout'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction queueRunner(options) {\n  const token = new _PCancelable.default((onCancel, resolve) => {\n    onCancel(resolve);\n  });\n\n  const mapper = ({\n    fn,\n    timeout,\n    initError = new Error()\n  }) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];\n\n        if (err) {\n          options.fail.apply(null, args);\n        }\n\n        resolve();\n      };\n\n      next.fail = function (...args) {\n        options.fail.apply(null, args);\n        resolve();\n      };\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve();\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise;\n    }\n\n    const timeoutMs = timeout();\n    return (0, _pTimeout.default)(promise, timeoutMs, options.clearTimeout, options.setTimeout, () => {\n      initError.message = 'Timeout - Async callback was not invoked within the ' + (0, _jestUtil.formatTime)(timeoutMs) + ' timeout specified by jest.setTimeout.';\n      initError.stack = initError.message + initError.stack;\n      options.onException(initError);\n    });\n  };\n\n  const result = options.queueableFns.reduce((promise, fn) => promise.then(() => mapper(fn)), Promise.resolve());\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    then: result.then.bind(result)\n  };\n}","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-jasmine2/build/queueRunner.js"],"names":["Object","defineProperty","exports","value","default","queueRunner","_jestUtil","require","_PCancelable","_interopRequireDefault","_pTimeout","obj","__esModule","Symbol","global","Promise","for","options","token","onCancel","resolve","mapper","fn","timeout","initError","Error","promise","next","args","err","fail","apply","call","userContext","e","onException","race","timeoutMs","clearTimeout","setTimeout","message","formatTime","stack","result","queueableFns","reduce","then","cancel","bind","catch"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = queueRunner;\n\nvar _jestUtil = require('jest-util');\n\nvar _PCancelable = _interopRequireDefault(require('./PCancelable'));\n\nvar _pTimeout = _interopRequireDefault(require('./pTimeout'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Promise = global[Symbol.for('jest-native-promise')] || global.Promise;\n\nfunction queueRunner(options) {\n  const token = new _PCancelable.default((onCancel, resolve) => {\n    onCancel(resolve);\n  });\n\n  const mapper = ({fn, timeout, initError = new Error()}) => {\n    let promise = new Promise(resolve => {\n      const next = function (...args) {\n        const err = args[0];\n\n        if (err) {\n          options.fail.apply(null, args);\n        }\n\n        resolve();\n      };\n\n      next.fail = function (...args) {\n        options.fail.apply(null, args);\n        resolve();\n      };\n\n      try {\n        fn.call(options.userContext, next);\n      } catch (e) {\n        options.onException(e);\n        resolve();\n      }\n    });\n    promise = Promise.race([promise, token]);\n\n    if (!timeout) {\n      return promise;\n    }\n\n    const timeoutMs = timeout();\n    return (0, _pTimeout.default)(\n      promise,\n      timeoutMs,\n      options.clearTimeout,\n      options.setTimeout,\n      () => {\n        initError.message =\n          'Timeout - Async callback was not invoked within the ' +\n          (0, _jestUtil.formatTime)(timeoutMs) +\n          ' timeout specified by jest.setTimeout.';\n        initError.stack = initError.message + initError.stack;\n        options.onException(initError);\n      }\n    );\n  };\n\n  const result = options.queueableFns.reduce(\n    (promise, fn) => promise.then(() => mapper(fn)),\n    Promise.resolve()\n  );\n  return {\n    cancel: token.cancel.bind(token),\n    catch: result.catch.bind(result),\n    then: result.then.bind(result)\n  };\n}\n"]},"metadata":{},"sourceType":"script"}