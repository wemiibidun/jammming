{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\"); // pattern for istanbul to ignore a section\n\n\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function (path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function (path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _core.template)(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = (0, _core.template)(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = (0, _core.template)(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _core.template)(`\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`, {\n  preserveComments: true\n}); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n  const T = types;\n  opts = { ..._schema.defaults.instrumentVisitor,\n    ...opts\n  };\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      }); // explicitly call this.varName to ensure coverage is always initialized\n\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/istanbul-lib-instrument/dist/visitor.js"],"names":["Object","defineProperty","exports","value","default","_crypto","require","_core","_schema","_sourceCoverage","_constants","COMMENT_RE","COMMENT_FILE_RE","SOURCE_MAP_RE","genVar","filename","hash","createHash","SHA","update","parseInt","digest","substr","toString","VisitState","constructor","types","sourceFilePath","inputSourceMap","ignoreClassMethods","varName","attrs","nextIgnore","cov","SourceCoverage","sourceMappingURL","shouldIgnore","path","node","loc","hintFor","hint","leadingComments","forEach","c","v","trim","groups","match","maybeAssignSourceMapURL","extractURL","comments","trailingComments","counterNeedsHoisting","isFunctionExpression","isArrowFunctionExpression","isClassExpression","onEnter","n","getAttr","some","name","id","isClassMethod","key","onExit","__cov__","setAttr","increase","type","index","T","wrap","x","memberExpression","numericLiteral","updateExpression","callExpression","identifier","insertCounter","increment","isBlockStatement","body","unshift","expressionStatement","isStatement","insertBefore","isVariableDeclarator","parentPath","parent","isExportNamedDeclaration","isProgram","replaceWith","sequenceExpression","isExpression","console","error","insertStatementCounter","newStatement","insertFunctionCounter","dloc","start","end","line","column","newFunction","get","getBranchIncrement","branchName","addBranchPath","insertBranchCounter","findLeaves","accumulator","property","left","right","push","entries","enter","wrappedEntry","e","call","exit","coverStatement","coverAssignmentPattern","b","newBranch","coverFunction","coverVariableDeclarator","coverClassPropDeclarator","makeBlock","blockStatement","undefined","blockProp","prop","makeParenthesizedExpressionForNonIdentifier","isIdentifier","parenthesizedExpression","parenthesizedExpressionProp","convertArrowExpression","bloc","expression","returnStatement","coverIfBranches","ignoreIf","ignoreElse","branch","consequent","alternate","createSwitchBranch","coverSwitchCase","Error","coverTernary","cHint","aHint","coverLogicalExpression","leaves","i","length","leaf","codeVisitor","ArrowFunctionExpression","AssignmentPattern","BlockStatement","ExportDefaultDeclaration","ExportNamedDeclaration","ClassMethod","ClassDeclaration","ClassProperty","ClassPrivateProperty","ObjectMethod","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","TryStatement","VariableDeclaration","VariableDeclarator","IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","SwitchStatement","SwitchCase","WithStatement","FunctionDeclaration","FunctionExpression","LabeledStatement","ConditionalExpression","LogicalExpression","globalTemplateAlteredFunction","template","globalTemplateFunction","globalTemplateVariable","coverageTemplate","preserveComments","alreadyInstrumented","visitState","scope","hasBinding","shouldIgnoreFile","programNode","test","programVisitor","opts","defaults","instrumentVisitor","find","p","traverse","freeze","coverageData","toJSON","fileCoverage","MAGIC_KEY","MAGIC_VALUE","JSON","stringify","coverageNode","valueToNode","gvTemplate","coverageGlobalScopeFunc","getBinding","GLOBAL_COVERAGE_SCOPE","stringLiteral","coverageGlobalScope","cv","GLOBAL_COVERAGE_VAR","coverageVariable","GLOBAL_COVERAGE_TEMPLATE","COVERAGE_FUNCTION","PATH","INITIAL","HASH","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\");\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function (path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function (path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _core.template)(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = (0, _core.template)(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = (0, _core.template)(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _core.template)(`\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`, {\n  preserveComments: true\n}); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n  const T = types;\n  opts = { ..._schema.defaults.instrumentVisitor,\n    ...opts\n  };\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      }); // explicitly call this.varName to ensure coverage is always initialized\n\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}