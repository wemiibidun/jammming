{"ast":null,"code":"'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ModuleNotFoundError = _interopRequireDefault(require('./ModuleNotFoundError'));\n\nvar _defaultResolver = _interopRequireWildcard(require('./defaultResolver'));\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nvar _shouldLoadAsEsm = _interopRequireWildcard(require('./shouldLoadAsEsm'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst NATIVE_PLATFORM = 'native'; // We might be inside a symlink.\n\nconst resolvedCwd = (0, _jestUtil().tryRealpath)(process.cwd());\nconst {\n  NODE_PATH\n} = process.env;\nconst nodePaths = NODE_PATH ? NODE_PATH.split(path().delimiter).filter(Boolean) // The resolver expects absolute paths.\n.map(p => path().resolve(resolvedCwd, p)) : undefined;\n\nclass Resolver {\n  constructor(moduleMap, options) {\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_moduleMap', void 0);\n\n    _defineProperty(this, '_moduleIDCache', void 0);\n\n    _defineProperty(this, '_moduleNameCache', void 0);\n\n    _defineProperty(this, '_modulePathCache', void 0);\n\n    _defineProperty(this, '_supportsNativePlatform', void 0);\n\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._supportsNativePlatform = options.platforms ? options.platforms.includes(NATIVE_PLATFORM) : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static tryCastModuleNotFoundError(error) {\n    if (error instanceof _ModuleNotFoundError.default) {\n      return error;\n    }\n\n    const casted = error;\n\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return _ModuleNotFoundError.default.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache() {\n    (0, _defaultResolver.clearDefaultResolverCache)();\n    (0, _shouldLoadAsEsm.clearCachedLookups)();\n  }\n\n  static findNodeModule(path, options) {\n    const resolver = options.resolver ? require(options.resolver) : _defaultResolver.default;\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        browser: options.browser,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n\n  resolveModuleFromDirIfExists(dirname, moduleName, options) {\n    const paths = options && options.paths || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const key = dirname + path().delimiter + moduleName;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    const extensions = this._options.extensions.slice();\n\n    let module;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext));\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + defaultPlatform + ext));\n    } // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n\n    const skipResolution = options && options.skipNodeResolution && !moduleName.includes(path().sep);\n\n    const resolveNodeModule = (name, throwIfNotFound = false) => Resolver.findNodeModule(name, {\n      basedir: dirname,\n      extensions,\n      moduleDirectory,\n      paths,\n      resolver: this._options.resolver,\n      rootDir: this._options.rootDir,\n      throwIfNotFound\n    });\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift());\n\n    if (hastePackage) {\n      try {\n        const module = path().join.apply(path(), [path().dirname(hastePackage)].concat(parts)); // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n\n        const resolvedModule = resolveNodeModule(module) || require.resolve(module);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      } catch {}\n    }\n\n    return null;\n  }\n\n  resolveModule(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module = this.resolveStubModuleName(from, moduleName) || this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    const relativePath = (0, _slash().default)(path().relative(this._options.rootDir, from)) || '.';\n    throw new _ModuleNotFoundError.default(`Cannot find module '${moduleName}' from '${relativePath}'`, moduleName);\n  }\n\n  _isAliasModule(moduleName) {\n    const moduleNameMapper = this._options.moduleNameMapper;\n\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(({\n      regex\n    }) => regex.test(moduleName));\n  }\n\n  isCoreModule(moduleName) {\n    return this._options.hasCoreModules && (0, _isBuiltinModule.default)(moduleName) && !this._isAliasModule(moduleName);\n  }\n\n  getModule(name) {\n    return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getModulePath(from, moduleName) {\n    if (moduleName[0] !== '.' || path().isAbsolute(moduleName)) {\n      return moduleName;\n    }\n\n    return path().normalize(path().dirname(from) + '/' + moduleName);\n  }\n\n  getPackage(name) {\n    return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform);\n  }\n\n  getMockModule(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  getModulePaths(from) {\n    const cachedModule = this._modulePathCache.get(from);\n\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = (0, _nodeModulesPaths.default)(from, {\n      moduleDirectory\n    });\n\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n\n    this._modulePathCache.set(from, paths);\n\n    return paths;\n  }\n\n  getModuleID(virtualMocks, from, _moduleName) {\n    const moduleName = _moduleName || '';\n    const key = from + path().delimiter + moduleName;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);\n\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = path().delimiter;\n    const id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  _getModuleType(moduleName) {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  _getAbsolutePath(virtualMocks, from, moduleName) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName);\n  }\n\n  _getMockPath(from, moduleName) {\n    return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;\n  }\n\n  _getVirtualMockPath(virtualMocks, from, moduleName) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks[virtualMockPath] ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName) : from;\n  }\n\n  _isModuleResolved(from, moduleName) {\n    return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));\n  }\n\n  resolveStubModuleName(from, moduleName) {\n    const dirname = path().dirname(from);\n    const paths = this._options.modulePaths;\n\n    const extensions = this._options.extensions.slice();\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext));\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(...this._options.extensions.map(ext => '.' + defaultPlatform + ext));\n    }\n\n    if (moduleNameMapper) {\n      for (const {\n        moduleName: mappedModuleName,\n        regex\n      } of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = matches ? moduleName => moduleName.replace(/\\$([0-9]+)/g, (_, index) => matches[parseInt(index, 10)]) : moduleName => moduleName;\n          const possibleModuleNames = Array.isArray(mappedModuleName) ? mappedModuleName : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module = this.getModule(updatedName) || Resolver.findNodeModule(updatedName, {\n              basedir: dirname,\n              extensions,\n              moduleDirectory,\n              paths,\n              resolver,\n              rootDir: this._options.rootDir\n            });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(moduleName, mapModuleName, mappedModuleName, regex, resolver);\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n\n}\n\n_defineProperty(Resolver, 'ModuleNotFoundError', _ModuleNotFoundError.default);\n\n_defineProperty(Resolver, 'unstable_shouldLoadAsEsm', _shouldLoadAsEsm.default);\n\nconst createNoMappedModuleFoundError = (moduleName, mapModuleName, mappedModuleName, regex, resolver) => {\n  const mappedAs = Array.isArray(mappedModuleName) ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2) : mappedModuleName;\n  const original = Array.isArray(mappedModuleName) ? JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n  .slice(0, -1) + '    ]' /// align last bracket correctly as well\n  : mappedModuleName;\n  const error = new Error(_chalk().default.red(`${_chalk().default.bold('Configuration error')}:\n\nCould not locate module ${_chalk().default.bold(moduleName)} mapped as:\n${_chalk().default.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${_chalk().default.bold(original)}\"\n  },\n  \"resolver\": ${_chalk().default.bold(String(resolver))}\n}`));\n  error.name = '';\n  return error;\n};\n\nmodule.exports = Resolver;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-config/node_modules/jest-resolve/build/index.js"],"names":["path","data","_interopRequireWildcard","require","_chalk","_interopRequireDefault","_slash","_jestUtil","_ModuleNotFoundError","_defaultResolver","_isBuiltinModule","_nodeModulesPaths","_shouldLoadAsEsm","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","value","enumerable","configurable","writable","NATIVE_PLATFORM","resolvedCwd","tryRealpath","process","cwd","NODE_PATH","env","nodePaths","split","delimiter","filter","Boolean","map","p","resolve","undefined","Resolver","constructor","moduleMap","options","_options","defaultPlatform","extensions","hasCoreModules","moduleDirectories","moduleNameMapper","modulePaths","platforms","resolver","rootDir","_supportsNativePlatform","includes","_moduleMap","_moduleIDCache","Map","_moduleNameCache","_modulePathCache","tryCastModuleNotFoundError","error","casted","code","duckType","clearDefaultResolverCache","clearCachedLookups","findNodeModule","paths","basedir","browser","defaultResolver","moduleDirectory","concat","e","throwIfNotFound","resolveModuleFromDirIfExists","dirname","moduleName","slice","module","unshift","ext","cacheResult","getModule","skipResolution","skipNodeResolution","sep","resolveNodeModule","name","versions","pnp","parts","hastePackage","getPackage","shift","join","apply","resolvedModule","resolveModule","from","resolveStubModuleName","relativePath","relative","_isAliasModule","some","regex","test","isCoreModule","getModulePath","isAbsolute","normalize","getMockModule","mock","getModulePaths","cachedModule","length","pop","getModuleID","virtualMocks","_moduleName","cachedModuleID","moduleType","_getModuleType","absolutePath","_getAbsolutePath","mockPath","_getMockPath","id","_isModuleResolved","_getVirtualMockPath","virtualMockPath","mappedModuleName","matches","match","mapModuleName","replace","_","index","parseInt","possibleModuleNames","Array","isArray","possibleModuleName","updatedName","createNoMappedModuleFoundError","mappedAs","JSON","stringify","original","Error","red","bold","toString","String","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _chalk() {\n  const data = _interopRequireDefault(require('chalk'));\n\n  _chalk = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _ModuleNotFoundError = _interopRequireDefault(\n  require('./ModuleNotFoundError')\n);\n\nvar _defaultResolver = _interopRequireWildcard(require('./defaultResolver'));\n\nvar _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));\n\nvar _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));\n\nvar _shouldLoadAsEsm = _interopRequireWildcard(require('./shouldLoadAsEsm'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst NATIVE_PLATFORM = 'native'; // We might be inside a symlink.\n\nconst resolvedCwd = (0, _jestUtil().tryRealpath)(process.cwd());\nconst {NODE_PATH} = process.env;\nconst nodePaths = NODE_PATH\n  ? NODE_PATH.split(path().delimiter)\n      .filter(Boolean) // The resolver expects absolute paths.\n      .map(p => path().resolve(resolvedCwd, p))\n  : undefined;\n\nclass Resolver {\n  constructor(moduleMap, options) {\n    _defineProperty(this, '_options', void 0);\n\n    _defineProperty(this, '_moduleMap', void 0);\n\n    _defineProperty(this, '_moduleIDCache', void 0);\n\n    _defineProperty(this, '_moduleNameCache', void 0);\n\n    _defineProperty(this, '_modulePathCache', void 0);\n\n    _defineProperty(this, '_supportsNativePlatform', void 0);\n\n    this._options = {\n      defaultPlatform: options.defaultPlatform,\n      extensions: options.extensions,\n      hasCoreModules:\n        options.hasCoreModules === undefined ? true : options.hasCoreModules,\n      moduleDirectories: options.moduleDirectories || ['node_modules'],\n      moduleNameMapper: options.moduleNameMapper,\n      modulePaths: options.modulePaths,\n      platforms: options.platforms,\n      resolver: options.resolver,\n      rootDir: options.rootDir\n    };\n    this._supportsNativePlatform = options.platforms\n      ? options.platforms.includes(NATIVE_PLATFORM)\n      : false;\n    this._moduleMap = moduleMap;\n    this._moduleIDCache = new Map();\n    this._moduleNameCache = new Map();\n    this._modulePathCache = new Map();\n  }\n\n  static tryCastModuleNotFoundError(error) {\n    if (error instanceof _ModuleNotFoundError.default) {\n      return error;\n    }\n\n    const casted = error;\n\n    if (casted.code === 'MODULE_NOT_FOUND') {\n      return _ModuleNotFoundError.default.duckType(casted);\n    }\n\n    return null;\n  }\n\n  static clearDefaultResolverCache() {\n    (0, _defaultResolver.clearDefaultResolverCache)();\n    (0, _shouldLoadAsEsm.clearCachedLookups)();\n  }\n\n  static findNodeModule(path, options) {\n    const resolver = options.resolver\n      ? require(options.resolver)\n      : _defaultResolver.default;\n    const paths = options.paths;\n\n    try {\n      return resolver(path, {\n        basedir: options.basedir,\n        browser: options.browser,\n        defaultResolver: _defaultResolver.default,\n        extensions: options.extensions,\n        moduleDirectory: options.moduleDirectory,\n        paths: paths ? (nodePaths || []).concat(paths) : nodePaths,\n        rootDir: options.rootDir\n      });\n    } catch (e) {\n      if (options.throwIfNotFound) {\n        throw e;\n      }\n    }\n\n    return null;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n  resolveModuleFromDirIfExists(dirname, moduleName, options) {\n    const paths = (options && options.paths) || this._options.modulePaths;\n    const moduleDirectory = this._options.moduleDirectories;\n    const key = dirname + path().delimiter + moduleName;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    const extensions = this._options.extensions.slice();\n\n    let module;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext)\n      );\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => '.' + defaultPlatform + ext)\n      );\n    } // 1. If we have already resolved this module for this directory name,\n    // return a value from the cache.\n\n    const cacheResult = this._moduleNameCache.get(key);\n\n    if (cacheResult) {\n      return cacheResult;\n    } // 2. Check if the module is a haste module.\n\n    module = this.getModule(moduleName);\n\n    if (module) {\n      this._moduleNameCache.set(key, module);\n\n      return module;\n    } // 3. Check if the module is a node module and resolve it based on\n    // the node module resolution algorithm. If skipNodeResolution is given we\n    // ignore all modules that look like node modules (ie. are not relative\n    // requires). This enables us to speed up resolution when we build a\n    // dependency graph because we don't have to look at modules that may not\n    // exist and aren't mocked.\n\n    const skipResolution =\n      options && options.skipNodeResolution && !moduleName.includes(path().sep);\n\n    const resolveNodeModule = (name, throwIfNotFound = false) =>\n      Resolver.findNodeModule(name, {\n        basedir: dirname,\n        extensions,\n        moduleDirectory,\n        paths,\n        resolver: this._options.resolver,\n        rootDir: this._options.rootDir,\n        throwIfNotFound\n      });\n\n    if (!skipResolution) {\n      module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));\n\n      if (module) {\n        this._moduleNameCache.set(key, module);\n\n        return module;\n      }\n    } // 4. Resolve \"haste packages\" which are `package.json` files outside of\n    // `node_modules` folders anywhere in the file system.\n\n    const parts = moduleName.split('/');\n    const hastePackage = this.getPackage(parts.shift());\n\n    if (hastePackage) {\n      try {\n        const module = path().join.apply(\n          path(),\n          [path().dirname(hastePackage)].concat(parts)\n        ); // try resolving with custom resolver first to support extensions,\n        // then fallback to require.resolve\n\n        const resolvedModule =\n          resolveNodeModule(module) || require.resolve(module);\n\n        this._moduleNameCache.set(key, resolvedModule);\n\n        return resolvedModule;\n      } catch {}\n    }\n\n    return null;\n  }\n\n  resolveModule(from, moduleName, options) {\n    const dirname = path().dirname(from);\n    const module =\n      this.resolveStubModuleName(from, moduleName) ||\n      this.resolveModuleFromDirIfExists(dirname, moduleName, options);\n    if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only\n    // produces an error based on the dirname but we have the actual current\n    // module name available.\n\n    const relativePath =\n      (0, _slash().default)(path().relative(this._options.rootDir, from)) ||\n      '.';\n    throw new _ModuleNotFoundError.default(\n      `Cannot find module '${moduleName}' from '${relativePath}'`,\n      moduleName\n    );\n  }\n\n  _isAliasModule(moduleName) {\n    const moduleNameMapper = this._options.moduleNameMapper;\n\n    if (!moduleNameMapper) {\n      return false;\n    }\n\n    return moduleNameMapper.some(({regex}) => regex.test(moduleName));\n  }\n\n  isCoreModule(moduleName) {\n    return (\n      this._options.hasCoreModules &&\n      (0, _isBuiltinModule.default)(moduleName) &&\n      !this._isAliasModule(moduleName)\n    );\n  }\n\n  getModule(name) {\n    return this._moduleMap.getModule(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform\n    );\n  }\n\n  getModulePath(from, moduleName) {\n    if (moduleName[0] !== '.' || path().isAbsolute(moduleName)) {\n      return moduleName;\n    }\n\n    return path().normalize(path().dirname(from) + '/' + moduleName);\n  }\n\n  getPackage(name) {\n    return this._moduleMap.getPackage(\n      name,\n      this._options.defaultPlatform,\n      this._supportsNativePlatform\n    );\n  }\n\n  getMockModule(from, name) {\n    const mock = this._moduleMap.getMockModule(name);\n\n    if (mock) {\n      return mock;\n    } else {\n      const moduleName = this.resolveStubModuleName(from, name);\n\n      if (moduleName) {\n        return this.getModule(moduleName) || moduleName;\n      }\n    }\n\n    return null;\n  }\n\n  getModulePaths(from) {\n    const cachedModule = this._modulePathCache.get(from);\n\n    if (cachedModule) {\n      return cachedModule;\n    }\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const paths = (0, _nodeModulesPaths.default)(from, {\n      moduleDirectory\n    });\n\n    if (paths[paths.length - 1] === undefined) {\n      // circumvent node-resolve bug that adds `undefined` as last item.\n      paths.pop();\n    }\n\n    this._modulePathCache.set(from, paths);\n\n    return paths;\n  }\n\n  getModuleID(virtualMocks, from, _moduleName) {\n    const moduleName = _moduleName || '';\n    const key = from + path().delimiter + moduleName;\n\n    const cachedModuleID = this._moduleIDCache.get(key);\n\n    if (cachedModuleID) {\n      return cachedModuleID;\n    }\n\n    const moduleType = this._getModuleType(moduleName);\n\n    const absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);\n\n    const mockPath = this._getMockPath(from, moduleName);\n\n    const sep = path().delimiter;\n    const id =\n      moduleType +\n      sep +\n      (absolutePath ? absolutePath + sep : '') +\n      (mockPath ? mockPath + sep : '');\n\n    this._moduleIDCache.set(key, id);\n\n    return id;\n  }\n\n  _getModuleType(moduleName) {\n    return this.isCoreModule(moduleName) ? 'node' : 'user';\n  }\n\n  _getAbsolutePath(virtualMocks, from, moduleName) {\n    if (this.isCoreModule(moduleName)) {\n      return moduleName;\n    }\n\n    return this._isModuleResolved(from, moduleName)\n      ? this.getModule(moduleName)\n      : this._getVirtualMockPath(virtualMocks, from, moduleName);\n  }\n\n  _getMockPath(from, moduleName) {\n    return !this.isCoreModule(moduleName)\n      ? this.getMockModule(from, moduleName)\n      : null;\n  }\n\n  _getVirtualMockPath(virtualMocks, from, moduleName) {\n    const virtualMockPath = this.getModulePath(from, moduleName);\n    return virtualMocks[virtualMockPath]\n      ? virtualMockPath\n      : moduleName\n      ? this.resolveModule(from, moduleName)\n      : from;\n  }\n\n  _isModuleResolved(from, moduleName) {\n    return !!(\n      this.getModule(moduleName) || this.getMockModule(from, moduleName)\n    );\n  }\n\n  resolveStubModuleName(from, moduleName) {\n    const dirname = path().dirname(from);\n    const paths = this._options.modulePaths;\n\n    const extensions = this._options.extensions.slice();\n\n    const moduleDirectory = this._options.moduleDirectories;\n    const moduleNameMapper = this._options.moduleNameMapper;\n    const resolver = this._options.resolver;\n    const defaultPlatform = this._options.defaultPlatform;\n\n    if (this._supportsNativePlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => '.' + NATIVE_PLATFORM + ext)\n      );\n    }\n\n    if (defaultPlatform) {\n      extensions.unshift(\n        ...this._options.extensions.map(ext => '.' + defaultPlatform + ext)\n      );\n    }\n\n    if (moduleNameMapper) {\n      for (const {moduleName: mappedModuleName, regex} of moduleNameMapper) {\n        if (regex.test(moduleName)) {\n          // Note: once a moduleNameMapper matches the name, it must result\n          // in a module, or else an error is thrown.\n          const matches = moduleName.match(regex);\n          const mapModuleName = matches\n            ? moduleName =>\n                moduleName.replace(\n                  /\\$([0-9]+)/g,\n                  (_, index) => matches[parseInt(index, 10)]\n                )\n            : moduleName => moduleName;\n          const possibleModuleNames = Array.isArray(mappedModuleName)\n            ? mappedModuleName\n            : [mappedModuleName];\n          let module = null;\n\n          for (const possibleModuleName of possibleModuleNames) {\n            const updatedName = mapModuleName(possibleModuleName);\n            module =\n              this.getModule(updatedName) ||\n              Resolver.findNodeModule(updatedName, {\n                basedir: dirname,\n                extensions,\n                moduleDirectory,\n                paths,\n                resolver,\n                rootDir: this._options.rootDir\n              });\n\n            if (module) {\n              break;\n            }\n          }\n\n          if (!module) {\n            throw createNoMappedModuleFoundError(\n              moduleName,\n              mapModuleName,\n              mappedModuleName,\n              regex,\n              resolver\n            );\n          }\n\n          return module;\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n_defineProperty(Resolver, 'ModuleNotFoundError', _ModuleNotFoundError.default);\n\n_defineProperty(Resolver, 'unstable_shouldLoadAsEsm', _shouldLoadAsEsm.default);\n\nconst createNoMappedModuleFoundError = (\n  moduleName,\n  mapModuleName,\n  mappedModuleName,\n  regex,\n  resolver\n) => {\n  const mappedAs = Array.isArray(mappedModuleName)\n    ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2)\n    : mappedModuleName;\n  const original = Array.isArray(mappedModuleName)\n    ? JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below\n        .slice(0, -1) + '    ]' /// align last bracket correctly as well\n    : mappedModuleName;\n  const error = new Error(\n    _chalk().default.red(`${_chalk().default.bold('Configuration error')}:\n\nCould not locate module ${_chalk().default.bold(moduleName)} mapped as:\n${_chalk().default.bold(mappedAs)}.\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"${regex.toString()}\": \"${_chalk().default.bold(original)}\"\n  },\n  \"resolver\": ${_chalk().default.bold(String(resolver))}\n}`)\n  );\n  error.name = '';\n  return error;\n};\n\nmodule.exports = Resolver;\n"]},"metadata":{},"sourceType":"script"}