{"ast":null,"code":"'use strict';\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _SnapshotResolver = require('./SnapshotResolver');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nvar _plugins = require('./plugins');\n\nvar _printSnapshot = require('./printSnapshot');\n\nvar utils = _interopRequireWildcard(require('./utils'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestExistsFile = global[Symbol.for('jest-native-exists-file')] || fs.existsSync;\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${(0, _jestMatcherUtils.BOLD_WEIGHT)('not')}`;\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printSnapshotName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return 'Snapshot name: `' + (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') + (hasNames && hasHint ? ': ' : '') + (hasHint ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint)) : '') + ' ' + count + '`';\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substr(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) => hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = '\\\\.' + _SnapshotResolver.EXTENSION + '$';\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nconst toMatchSnapshot = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (typeof propertiesOrHint !== 'object' || propertiesOrHint === null) {\n      const options = {\n        isNot: this.isNot,\n        promise: this.promise\n      };\n      let printedWithType = (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrHint, _printSnapshot.printExpected);\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = _jestMatcherUtils.BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType += `\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')`;\n        }\n      }\n\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')} must be an object`, printedWithType));\n    } // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nconst toMatchInlineSnapshot = function (received, propertiesOrSnapshot, inlineSnapshot) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (length === 3) {\n      options.secondArgument = _printSnapshot.SNAPSHOT_ARG;\n      options.secondArgumentColor = _printSnapshot.noColor;\n    }\n\n    if (typeof propertiesOrSnapshot !== 'object' || propertiesOrSnapshot === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')} must be an object`, (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrSnapshot, _printSnapshot.printExpected)));\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), `Inline snapshot must be a string`, (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, utils.serialize)));\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,\n    isInline: true,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nconst _toMatchSnapshot = config => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    properties\n  } = config;\n  let {\n    received\n  } = config;\n  context.dontThrow && context.dontThrow();\n  const {\n    currentTestName,\n    isNot,\n    snapshotState\n  } = context;\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error((0, _printSnapshot.matcherHintFromConfig)(config, false) + '\\n\\n' + `Snapshot state must be initialized` + '\\n\\n' + (0, _jestMatcherUtils.printWithType)('Snapshot state', snapshotState, _jestMatcherUtils.stringify));\n  }\n\n  const fullTestName = currentTestName && hint ? `${currentTestName}: ${hint}` : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be an object when the matcher has ${(0, _jestMatcherUtils.EXPECTED_COLOR)('properties')}`, (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));\n    }\n\n    const propertyPass = context.equals(received, properties, [context.utils.iterableEquality, context.utils.subsetEquality]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () => (0, _printSnapshot.matcherHintFromConfig)(config, false) + '\\n\\n' + printSnapshotName(currentTestName, hint, count) + '\\n\\n' + (0, _printSnapshot.printPropertiesAndReceived)(properties, received, snapshotState.expand);\n\n      return {\n        message,\n        name: matcherName,\n        pass: false\n      };\n    } else {\n      received = utils.deepMerge(received, properties);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testName: fullTestName\n  });\n  const {\n    actual,\n    count,\n    expected,\n    pass\n  } = result;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  }\n\n  const message = expected === undefined ? () => (0, _printSnapshot.matcherHintFromConfig)(config, true) + '\\n\\n' + printSnapshotName(currentTestName, hint, count) + '\\n\\n' + `New snapshot was ${(0, _jestMatcherUtils.BOLD_WEIGHT)('not written')}. The update flag ` + `must be explicitly passed to write a new snapshot.\\n\\n` + `This is likely because this test is run in a continuous integration ` + `(CI) environment in which snapshots are not written by default.\\n\\n` + `Received:${actual.includes('\\n') ? '\\n' : ' '}${(0, _printSnapshot.bReceivedColor)(actual)}` : () => (0, _printSnapshot.matcherHintFromConfig)(config, true) + '\\n\\n' + printSnapshotName(currentTestName, hint, count) + '\\n\\n' + (0, _printSnapshot.printSnapshotAndReceived)(expected, actual, received, snapshotState.expand); // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function (received, hint, // because error TS1016 for hint?: string\nfromPromise) {\n  const matcherName = 'toThrowErrorMatchingSnapshot'; // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    received\n  }, fromPromise);\n};\n\nconst toThrowErrorMatchingInlineSnapshot = function (received, inlineSnapshot, fromPromise) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options = {\n      expectedColor: _printSnapshot.noColor,\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.SNAPSHOT_ARG, options), `Inline snapshot must be a string`, (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, utils.serialize)));\n  }\n\n  return _toThrowErrorMatchingSnapshot({\n    context: this,\n    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,\n    isInline: true,\n    matcherName,\n    received\n  }, fromPromise);\n};\n\nconst _toThrowErrorMatchingSnapshot = (config, fromPromise) => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received\n  } = config;\n  context.dontThrow && context.dontThrow();\n  const {\n    isNot,\n    promise\n  } = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options = {\n        isNot,\n        promise\n      };\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options), `${(0, _jestMatcherUtils.RECEIVED_COLOR)('received')} value must be a function`, (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));\n    }\n  }\n\n  if (isNot) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error((0, _printSnapshot.matcherHintFromConfig)(config, false) + '\\n\\n' + DID_NOT_THROW);\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: error.message\n  });\n};\n\nconst JestSnapshot = {\n  EXTENSION: _SnapshotResolver.EXTENSION,\n  SnapshotState: _State.default,\n  addSerializer: _plugins.addSerializer,\n  buildSnapshotResolver: _SnapshotResolver.buildSnapshotResolver,\n  cleanup,\n  getSerializers: _plugins.getSerializers,\n  isSnapshotPath: _SnapshotResolver.isSnapshotPath,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n  utils\n};\nmodule.exports = JestSnapshot;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-snapshot/build/index.js"],"names":["fs","_interopRequireWildcard","require","_jestMatcherUtils","_SnapshotResolver","_State","_interopRequireDefault","_plugins","_printSnapshot","utils","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","global","jestExistsFile","for","existsSync","DID_NOT_THROW","NOT_SNAPSHOT_MATCHERS","BOLD_WEIGHT","INDENTATION_REGEX","printSnapshotName","concatenatedBlockNames","hint","count","hasNames","length","hasHint","escapeBacktickString","stripAddedIndentation","inlineSnapshot","match","indentation","lines","split","trim","i","indexOf","substr","join","fileExists","filePath","hasteFS","exists","cleanup","update","snapshotResolver","testPathIgnorePatterns","pattern","EXTENSION","files","matchFiles","testIgnorePatternsRegex","RegExp","list","filter","snapshotFile","testPath","resolveTestPath","test","unlinkSync","filesRemoved","filesRemovedList","toMatchSnapshot","received","propertiesOrHint","matcherName","properties","arguments","options","isNot","promise","printedWithType","printWithType","printExpected","secondArgument","secondArgumentColor","Error","matcherErrorMessage","matcherHint","undefined","PROPERTIES_ARG","EXPECTED_COLOR","_toMatchSnapshot","context","isInline","toMatchInlineSnapshot","propertiesOrSnapshot","SNAPSHOT_ARG","noColor","serialize","config","dontThrow","currentTestName","snapshotState","matcherHintFromConfig","stringify","fullTestName","RECEIVED_COLOR","printReceived","propertyPass","equals","iterableEquality","subsetEquality","fail","matched","exec","Number","message","printPropertiesAndReceived","expand","name","pass","deepMerge","result","error","testName","actual","expected","includes","bReceivedColor","printSnapshotAndReceived","toThrowErrorMatchingSnapshot","fromPromise","_toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot","expectedColor","e","JestSnapshot","SnapshotState","addSerializer","buildSnapshotResolver","getSerializers","isSnapshotPath","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _SnapshotResolver = require('./SnapshotResolver');\n\nvar _State = _interopRequireDefault(require('./State'));\n\nvar _plugins = require('./plugins');\n\nvar _printSnapshot = require('./printSnapshot');\n\nvar utils = _interopRequireWildcard(require('./utils'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestExistsFile =\n  global[Symbol.for('jest-native-exists-file')] || fs.existsSync;\nconst DID_NOT_THROW = 'Received function did not throw'; // same as toThrow\n\nconst NOT_SNAPSHOT_MATCHERS = `Snapshot matchers cannot be used with ${(0,\n_jestMatcherUtils.BOLD_WEIGHT)('not')}`;\nconst INDENTATION_REGEX = /^([^\\S\\n]*)\\S/m; // Display name in report when matcher fails same as in snapshot file,\n// but with optional hint argument in bold weight.\n\nconst printSnapshotName = (concatenatedBlockNames = '', hint = '', count) => {\n  const hasNames = concatenatedBlockNames.length !== 0;\n  const hasHint = hint.length !== 0;\n  return (\n    'Snapshot name: `' +\n    (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') +\n    (hasNames && hasHint ? ': ' : '') +\n    (hasHint\n      ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint))\n      : '') +\n    ' ' +\n    count +\n    '`'\n  );\n};\n\nfunction stripAddedIndentation(inlineSnapshot) {\n  // Find indentation if exists.\n  const match = inlineSnapshot.match(INDENTATION_REGEX);\n\n  if (!match || !match[1]) {\n    // No indentation.\n    return inlineSnapshot;\n  }\n\n  const indentation = match[1];\n  const lines = inlineSnapshot.split('\\n');\n\n  if (lines.length <= 2) {\n    // Must be at least 3 lines.\n    return inlineSnapshot;\n  }\n\n  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {\n    // If not blank first and last lines, abort.\n    return inlineSnapshot;\n  }\n\n  for (let i = 1; i < lines.length - 1; i++) {\n    if (lines[i] !== '') {\n      if (lines[i].indexOf(indentation) !== 0) {\n        // All lines except first and last should either be blank or have the same\n        // indent as the first line (or more). If this isn't the case we don't\n        // want to touch the snapshot at all.\n        return inlineSnapshot;\n      }\n\n      lines[i] = lines[i].substr(indentation.length);\n    }\n  } // Last line is a special case because it won't have the same indent as others\n  // but may still have been given some indent to line up.\n\n  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.\n\n  inlineSnapshot = lines.join('\\n');\n  return inlineSnapshot;\n}\n\nconst fileExists = (filePath, hasteFS) =>\n  hasteFS.exists(filePath) || jestExistsFile(filePath);\n\nconst cleanup = (hasteFS, update, snapshotResolver, testPathIgnorePatterns) => {\n  const pattern = '\\\\.' + _SnapshotResolver.EXTENSION + '$';\n  const files = hasteFS.matchFiles(pattern);\n  let testIgnorePatternsRegex = null;\n\n  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {\n    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));\n  }\n\n  const list = files.filter(snapshotFile => {\n    const testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests\n\n    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {\n      return false;\n    }\n\n    if (!fileExists(testPath, hasteFS)) {\n      if (update === 'all') {\n        fs.unlinkSync(snapshotFile);\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return {\n    filesRemoved: list.length,\n    filesRemovedList: list\n  };\n};\n\nconst toMatchSnapshot = function (received, propertiesOrHint, hint) {\n  const matcherName = 'toMatchSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrHint === 'string') {\n    hint = propertiesOrHint;\n  } else if (length >= 2) {\n    if (typeof propertiesOrHint !== 'object' || propertiesOrHint === null) {\n      const options = {\n        isNot: this.isNot,\n        promise: this.promise\n      };\n      let printedWithType = (0, _jestMatcherUtils.printWithType)(\n        'Expected properties',\n        propertiesOrHint,\n        _printSnapshot.printExpected\n      );\n\n      if (length === 3) {\n        options.secondArgument = 'hint';\n        options.secondArgumentColor = _jestMatcherUtils.BOLD_WEIGHT;\n\n        if (propertiesOrHint == null) {\n          printedWithType += `\\n\\nTo provide a hint without properties: toMatchSnapshot('hint')`;\n        }\n      }\n\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)(\n            'properties'\n          )} must be an object`,\n          printedWithType\n        )\n      );\n    } // Future breaking change: Snapshot hint must be a string\n    // if (arguments.length === 3 && typeof hint !== 'string') {}\n\n    properties = propertiesOrHint;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    hint,\n    isInline: false,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nconst toMatchInlineSnapshot = function (\n  received,\n  propertiesOrSnapshot,\n  inlineSnapshot\n) {\n  const matcherName = 'toMatchInlineSnapshot';\n  let properties;\n  const length = arguments.length;\n\n  if (length === 2 && typeof propertiesOrSnapshot === 'string') {\n    inlineSnapshot = propertiesOrSnapshot;\n  } else if (length >= 2) {\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n\n    if (length === 3) {\n      options.secondArgument = _printSnapshot.SNAPSHOT_ARG;\n      options.secondArgumentColor = _printSnapshot.noColor;\n    }\n\n    if (\n      typeof propertiesOrSnapshot !== 'object' ||\n      propertiesOrSnapshot === null\n    ) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          `Expected ${(0, _jestMatcherUtils.EXPECTED_COLOR)(\n            'properties'\n          )} must be an object`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Expected properties',\n            propertiesOrSnapshot,\n            _printSnapshot.printExpected\n          )\n        )\n      );\n    }\n\n    if (length === 3 && typeof inlineSnapshot !== 'string') {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            _printSnapshot.PROPERTIES_ARG,\n            options\n          ),\n          `Inline snapshot must be a string`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Inline snapshot',\n            inlineSnapshot,\n            utils.serialize\n          )\n        )\n      );\n    }\n\n    properties = propertiesOrSnapshot;\n  }\n\n  return _toMatchSnapshot({\n    context: this,\n    inlineSnapshot:\n      inlineSnapshot !== undefined\n        ? stripAddedIndentation(inlineSnapshot)\n        : undefined,\n    isInline: true,\n    matcherName,\n    properties,\n    received\n  });\n};\n\nconst _toMatchSnapshot = config => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    properties\n  } = config;\n  let {received} = config;\n  context.dontThrow && context.dontThrow();\n  const {currentTestName, isNot, snapshotState} = context;\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _printSnapshot.matcherHintFromConfig)(config, false),\n        NOT_SNAPSHOT_MATCHERS\n      )\n    );\n  }\n\n  if (snapshotState == null) {\n    // Because the state is the problem, this is not a matcher error.\n    // Call generic stringify from jest-matcher-utils package\n    // because uninitialized snapshot state does not need snapshot serializers.\n    throw new Error(\n      (0, _printSnapshot.matcherHintFromConfig)(config, false) +\n        '\\n\\n' +\n        `Snapshot state must be initialized` +\n        '\\n\\n' +\n        (0, _jestMatcherUtils.printWithType)(\n          'Snapshot state',\n          snapshotState,\n          _jestMatcherUtils.stringify\n        )\n    );\n  }\n\n  const fullTestName =\n    currentTestName && hint\n      ? `${currentTestName}: ${hint}`\n      : currentTestName || ''; // future BREAKING change: || hint\n\n  if (typeof properties === 'object') {\n    if (typeof received !== 'object' || received === null) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _printSnapshot.matcherHintFromConfig)(config, false),\n          `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n            'received'\n          )} value must be an object when the matcher has ${(0,\n          _jestMatcherUtils.EXPECTED_COLOR)('properties')}`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Received',\n            received,\n            _printSnapshot.printReceived\n          )\n        )\n      );\n    }\n\n    const propertyPass = context.equals(received, properties, [\n      context.utils.iterableEquality,\n      context.utils.subsetEquality\n    ]);\n\n    if (!propertyPass) {\n      const key = snapshotState.fail(fullTestName, received);\n      const matched = /(\\d+)$/.exec(key);\n      const count = matched === null ? 1 : Number(matched[1]);\n\n      const message = () =>\n        (0, _printSnapshot.matcherHintFromConfig)(config, false) +\n        '\\n\\n' +\n        printSnapshotName(currentTestName, hint, count) +\n        '\\n\\n' +\n        (0, _printSnapshot.printPropertiesAndReceived)(\n          properties,\n          received,\n          snapshotState.expand\n        );\n\n      return {\n        message,\n        name: matcherName,\n        pass: false\n      };\n    } else {\n      received = utils.deepMerge(received, properties);\n    }\n  }\n\n  const result = snapshotState.match({\n    error: context.error,\n    inlineSnapshot,\n    isInline,\n    received,\n    testName: fullTestName\n  });\n  const {actual, count, expected, pass} = result;\n\n  if (pass) {\n    return {\n      message: () => '',\n      pass: true\n    };\n  }\n\n  const message =\n    expected === undefined\n      ? () =>\n          (0, _printSnapshot.matcherHintFromConfig)(config, true) +\n          '\\n\\n' +\n          printSnapshotName(currentTestName, hint, count) +\n          '\\n\\n' +\n          `New snapshot was ${(0, _jestMatcherUtils.BOLD_WEIGHT)(\n            'not written'\n          )}. The update flag ` +\n          `must be explicitly passed to write a new snapshot.\\n\\n` +\n          `This is likely because this test is run in a continuous integration ` +\n          `(CI) environment in which snapshots are not written by default.\\n\\n` +\n          `Received:${actual.includes('\\n') ? '\\n' : ' '}${(0,\n          _printSnapshot.bReceivedColor)(actual)}`\n      : () =>\n          (0, _printSnapshot.matcherHintFromConfig)(config, true) +\n          '\\n\\n' +\n          printSnapshotName(currentTestName, hint, count) +\n          '\\n\\n' +\n          (0, _printSnapshot.printSnapshotAndReceived)(\n            expected,\n            actual,\n            received,\n            snapshotState.expand\n          ); // Passing the actual and expected objects so that a custom reporter\n  // could access them, for example in order to display a custom visual diff,\n  // or create a different error message\n\n  return {\n    actual,\n    expected,\n    message,\n    name: matcherName,\n    pass: false\n  };\n};\n\nconst toThrowErrorMatchingSnapshot = function (\n  received,\n  hint, // because error TS1016 for hint?: string\n  fromPromise\n) {\n  const matcherName = 'toThrowErrorMatchingSnapshot'; // Future breaking change: Snapshot hint must be a string\n  // if (hint !== undefined && typeof hint !== string) {}\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      hint,\n      isInline: false,\n      matcherName,\n      received\n    },\n    fromPromise\n  );\n};\n\nconst toThrowErrorMatchingInlineSnapshot = function (\n  received,\n  inlineSnapshot,\n  fromPromise\n) {\n  const matcherName = 'toThrowErrorMatchingInlineSnapshot';\n\n  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {\n    const options = {\n      expectedColor: _printSnapshot.noColor,\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          _printSnapshot.SNAPSHOT_ARG,\n          options\n        ),\n        `Inline snapshot must be a string`,\n        (0, _jestMatcherUtils.printWithType)(\n          'Inline snapshot',\n          inlineSnapshot,\n          utils.serialize\n        )\n      )\n    );\n  }\n\n  return _toThrowErrorMatchingSnapshot(\n    {\n      context: this,\n      inlineSnapshot:\n        inlineSnapshot !== undefined\n          ? stripAddedIndentation(inlineSnapshot)\n          : undefined,\n      isInline: true,\n      matcherName,\n      received\n    },\n    fromPromise\n  );\n};\n\nconst _toThrowErrorMatchingSnapshot = (config, fromPromise) => {\n  const {\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received\n  } = config;\n  context.dontThrow && context.dontThrow();\n  const {isNot, promise} = context;\n\n  if (!fromPromise) {\n    if (typeof received !== 'function') {\n      const options = {\n        isNot,\n        promise\n      };\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            '',\n            options\n          ),\n          `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n            'received'\n          )} value must be a function`,\n          (0, _jestMatcherUtils.printWithType)(\n            'Received',\n            received,\n            _printSnapshot.printReceived\n          )\n        )\n      );\n    }\n  }\n\n  if (isNot) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _printSnapshot.matcherHintFromConfig)(config, false),\n        NOT_SNAPSHOT_MATCHERS\n      )\n    );\n  }\n\n  let error;\n\n  if (fromPromise) {\n    error = received;\n  } else {\n    try {\n      received();\n    } catch (e) {\n      error = e;\n    }\n  }\n\n  if (error === undefined) {\n    // Because the received value is a function, this is not a matcher error.\n    throw new Error(\n      (0, _printSnapshot.matcherHintFromConfig)(config, false) +\n        '\\n\\n' +\n        DID_NOT_THROW\n    );\n  }\n\n  return _toMatchSnapshot({\n    context,\n    hint,\n    inlineSnapshot,\n    isInline,\n    matcherName,\n    received: error.message\n  });\n};\n\nconst JestSnapshot = {\n  EXTENSION: _SnapshotResolver.EXTENSION,\n  SnapshotState: _State.default,\n  addSerializer: _plugins.addSerializer,\n  buildSnapshotResolver: _SnapshotResolver.buildSnapshotResolver,\n  cleanup,\n  getSerializers: _plugins.getSerializers,\n  isSnapshotPath: _SnapshotResolver.isSnapshotPath,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n  utils\n};\nmodule.exports = JestSnapshot;\n"]},"metadata":{},"sourceType":"script"}