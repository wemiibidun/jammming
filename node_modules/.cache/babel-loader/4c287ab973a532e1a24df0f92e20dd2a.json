{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  }\n\n  token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/@babel/generator/lib/printer.js"],"names":["Object","defineProperty","exports","value","default","_buffer","require","n","t","generatorFunctions","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","WeakSet","_endsWithInteger","_endsWithWord","_buf","generate","ast","print","_maybeAddAuxComment","get","indent","compact","concise","dedent","semicolon","force","_append","rightBrace","minified","removeLastSemicolon","token","space","hasContent","endsWith","_space","word","str","indexOf","number","Number","isInteger","test","length","newline","i","retainLines","Math","min","j","_newline","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","withSource","queue","_maybeAddParen","_maybeIndent","append","_getIndent","parenPushNewlineState","cha","chaPost","slice","printed","pos","line","count","getCurrentLine","style","repeat","startTerminatorless","isLabel","endTerminatorless","state","node","parent","oldConcise","_compact","printMethod","type","ReferenceError","JSON","stringify","name","push","oldInAux","needsParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","isProgram","isFile","call","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","printAndIndentOnComments","leadingComments","printBlock","body","isEmptyStatement","_printComments","_getComments","printInnerComments","_node$innerComments","innerComments","printSequence","printList","items","commaSeparator","leading","lines","needs","needsWhitespaceBefore","needsWhitespaceAfter","trailingComments","skipNewLines","shouldPrintComment","ignore","has","add","isBlockComment","printNewLines","val","adjustMultilineComment","_comment$loc","offset","start","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","comments","inlinePureAnnotation","printAssertions","_node$assertions","assertions","assign","prototype","Noop","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (this._buf.hasContent() && !this.endsWith(\" \") && !this.endsWith(\"\\n\") || force) {\n      this._space();\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(\"/\") && str.indexOf(\"/\") === 0) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== \".\";\n  }\n\n  token(str) {\n    if (str === \"--\" && this.endsWith(\"!\") || str[0] === \"+\" && this.endsWith(\"+\") || str[0] === \"-\" && this.endsWith(\"-\") || str[0] === \".\" && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    if (this.endsWith(\"\\n\\n\")) return;\n    if (typeof i !== \"number\") i = 1;\n    i = Math.min(2, i);\n    if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(str) {\n    return this._buf.endsWith(str);\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(\"\\n\") && str[0] !== \"\\n\") {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let needsParens = n.needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      needsParens = true;\n    }\n\n    if (needsParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = t.isProgram(node) || t.isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (needsParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!t.isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(lines);\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    if (!this.endsWith(\"[\") && !this.endsWith(\"{\")) this.space();\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(\"/\")) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(\"\\n\"));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}"]},"metadata":{},"sourceType":"script"}