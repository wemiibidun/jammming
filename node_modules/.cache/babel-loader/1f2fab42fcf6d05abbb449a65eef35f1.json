{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = _default;\n\nvar _assert = require('assert');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _jestUtil = require('jest-util');\n\nvar _assertionErrorMessage = _interopRequireDefault(require('../assertionErrorMessage'));\n\nvar _isError = _interopRequireDefault(require('../isError'));\n\nvar _queueRunner = _interopRequireDefault(require('../queueRunner'));\n\nvar _treeProcessor = _interopRequireDefault(require('../treeProcessor'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _default(j$) {\n  var _temp;\n\n  return _temp = class Env {\n    constructor(_options) {\n      _defineProperty(this, 'specFilter', void 0);\n\n      _defineProperty(this, 'catchExceptions', void 0);\n\n      _defineProperty(this, 'throwOnExpectationFailure', void 0);\n\n      _defineProperty(this, 'catchingExceptions', void 0);\n\n      _defineProperty(this, 'topSuite', void 0);\n\n      _defineProperty(this, 'fail', void 0);\n\n      _defineProperty(this, 'pending', void 0);\n\n      _defineProperty(this, 'afterAll', void 0);\n\n      _defineProperty(this, 'fit', void 0);\n\n      _defineProperty(this, 'throwingExpectationFailures', void 0);\n\n      _defineProperty(this, 'randomizeTests', void 0);\n\n      _defineProperty(this, 'randomTests', void 0);\n\n      _defineProperty(this, 'seed', void 0);\n\n      _defineProperty(this, 'execute', void 0);\n\n      _defineProperty(this, 'fdescribe', void 0);\n\n      _defineProperty(this, 'spyOn', void 0);\n\n      _defineProperty(this, 'beforeEach', void 0);\n\n      _defineProperty(this, 'afterEach', void 0);\n\n      _defineProperty(this, 'clearReporters', void 0);\n\n      _defineProperty(this, 'addReporter', void 0);\n\n      _defineProperty(this, 'it', void 0);\n\n      _defineProperty(this, 'xdescribe', void 0);\n\n      _defineProperty(this, 'xit', void 0);\n\n      _defineProperty(this, 'beforeAll', void 0);\n\n      _defineProperty(this, 'todo', void 0);\n\n      _defineProperty(this, 'provideFallbackReporter', void 0);\n\n      _defineProperty(this, 'allowRespy', void 0);\n\n      _defineProperty(this, 'describe', void 0);\n\n      let totalSpecsDefined = 0;\n      let catchExceptions = true;\n      const realSetTimeout = global.setTimeout;\n      const realClearTimeout = global.clearTimeout;\n      const runnableResources = {};\n      const currentlyExecutingSuites = [];\n      let currentSpec = null;\n      let throwOnExpectationFailure = false;\n      let random = false;\n      let seed = null;\n      let nextSpecId = 0;\n      let nextSuiteId = 0;\n\n      const getNextSpecId = function () {\n        return 'spec' + nextSpecId++;\n      };\n\n      const getNextSuiteId = function () {\n        return 'suite' + nextSuiteId++;\n      };\n\n      const topSuite = new j$.Suite({\n        id: getNextSuiteId(),\n        description: '',\n\n        getTestPath() {\n          return j$.testPath;\n        }\n\n      });\n      let currentDeclarationSuite = topSuite;\n\n      const currentSuite = function () {\n        return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n      };\n\n      const currentRunnable = function () {\n        return currentSpec || currentSuite();\n      };\n\n      const reporter = new j$.ReportDispatcher(['jasmineStarted', 'jasmineDone', 'suiteStarted', 'suiteDone', 'specStarted', 'specDone']);\n\n      this.specFilter = function () {\n        return true;\n      };\n\n      const defaultResourcesForRunnable = function (id, _parentRunnableId) {\n        const resources = {\n          spies: []\n        };\n        runnableResources[id] = resources;\n      };\n\n      const clearResourcesForRunnable = function (id) {\n        spyRegistry.clearSpies();\n        delete runnableResources[id];\n      };\n\n      const beforeAndAfterFns = function (suite) {\n        return function () {\n          let afters = [];\n          let befores = [];\n\n          while (suite) {\n            befores = befores.concat(suite.beforeFns);\n            afters = afters.concat(suite.afterFns);\n            suite = suite.parentSuite;\n          }\n\n          return {\n            befores: befores.reverse(),\n            afters\n          };\n        };\n      };\n\n      const getSpecName = function (spec, suite) {\n        const fullName = [spec.description];\n        const suiteFullName = suite.getFullName();\n\n        if (suiteFullName !== '') {\n          fullName.unshift(suiteFullName);\n        }\n\n        return fullName.join(' ');\n      };\n\n      this.catchExceptions = function (value) {\n        catchExceptions = !!value;\n        return catchExceptions;\n      };\n\n      this.catchingExceptions = function () {\n        return catchExceptions;\n      };\n\n      this.throwOnExpectationFailure = function (value) {\n        throwOnExpectationFailure = !!value;\n      };\n\n      this.throwingExpectationFailures = function () {\n        return throwOnExpectationFailure;\n      };\n\n      this.randomizeTests = function (value) {\n        random = !!value;\n      };\n\n      this.randomTests = function () {\n        return random;\n      };\n\n      this.seed = function (value) {\n        if (value) {\n          seed = value;\n        }\n\n        return seed;\n      };\n\n      const queueRunnerFactory = options => {\n        options.clearTimeout = realClearTimeout;\n        options.fail = this.fail;\n        options.setTimeout = realSetTimeout;\n        return (0, _queueRunner.default)(options);\n      };\n\n      this.topSuite = function () {\n        return topSuite;\n      };\n\n      const uncaught = err => {\n        if (currentSpec) {\n          currentSpec.onException(err);\n          currentSpec.cancel();\n        } else {\n          console.error('Unhandled error');\n          console.error(err.stack);\n        }\n      };\n\n      let oldListenersException;\n      let oldListenersRejection;\n\n      const executionSetup = function () {\n        // Need to ensure we are the only ones handling these exceptions.\n        oldListenersException = process.listeners('uncaughtException').slice();\n        oldListenersRejection = process.listeners('unhandledRejection').slice();\n        j$.process.removeAllListeners('uncaughtException');\n        j$.process.removeAllListeners('unhandledRejection');\n        j$.process.on('uncaughtException', uncaught);\n        j$.process.on('unhandledRejection', uncaught);\n      };\n\n      const executionTeardown = function () {\n        j$.process.removeListener('uncaughtException', uncaught);\n        j$.process.removeListener('unhandledRejection', uncaught); // restore previous exception handlers\n\n        oldListenersException.forEach(listener => {\n          j$.process.on('uncaughtException', listener);\n        });\n        oldListenersRejection.forEach(listener => {\n          j$.process.on('unhandledRejection', listener);\n        });\n      };\n\n      this.execute = async function (runnablesToRun, suiteTree = topSuite) {\n        if (!runnablesToRun) {\n          if (focusedRunnables.length) {\n            runnablesToRun = focusedRunnables;\n          } else {\n            runnablesToRun = [suiteTree.id];\n          }\n        }\n\n        if (currentlyExecutingSuites.length === 0) {\n          executionSetup();\n        }\n\n        const lastDeclarationSuite = currentDeclarationSuite;\n        await (0, _treeProcessor.default)({\n          nodeComplete(suite) {\n            if (!suite.disabled) {\n              clearResourcesForRunnable(suite.id);\n            }\n\n            currentlyExecutingSuites.pop();\n\n            if (suite === topSuite) {\n              reporter.jasmineDone({\n                failedExpectations: topSuite.result.failedExpectations\n              });\n            } else {\n              reporter.suiteDone(suite.getResult());\n            }\n          },\n\n          nodeStart(suite) {\n            currentlyExecutingSuites.push(suite);\n            defaultResourcesForRunnable(suite.id, suite.parentSuite && suite.parentSuite.id);\n\n            if (suite === topSuite) {\n              reporter.jasmineStarted({\n                totalSpecsDefined\n              });\n            } else {\n              reporter.suiteStarted(suite.result);\n            }\n          },\n\n          queueRunnerFactory,\n          runnableIds: runnablesToRun,\n          tree: suiteTree\n        });\n        currentDeclarationSuite = lastDeclarationSuite;\n\n        if (currentlyExecutingSuites.length === 0) {\n          executionTeardown();\n        }\n      };\n\n      this.addReporter = function (reporterToAdd) {\n        reporter.addReporter(reporterToAdd);\n      };\n\n      this.provideFallbackReporter = function (reporterToAdd) {\n        reporter.provideFallbackReporter(reporterToAdd);\n      };\n\n      this.clearReporters = function () {\n        reporter.clearReporters();\n      };\n\n      const spyRegistry = new j$.SpyRegistry({\n        currentSpies() {\n          if (!currentRunnable()) {\n            throw new Error('Spies must be created in a before function or a spec');\n          }\n\n          return runnableResources[currentRunnable().id].spies;\n        }\n\n      });\n\n      this.allowRespy = function (allow) {\n        spyRegistry.allowRespy(allow);\n      };\n\n      this.spyOn = function (...args) {\n        return spyRegistry.spyOn.apply(spyRegistry, args);\n      };\n\n      const suiteFactory = function (description) {\n        const suite = new j$.Suite({\n          id: getNextSuiteId(),\n          description,\n          parentSuite: currentDeclarationSuite,\n          throwOnExpectationFailure,\n\n          getTestPath() {\n            return j$.testPath;\n          }\n\n        });\n        return suite;\n      };\n\n      this.describe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n\n        if (specDefinitions === undefined) {\n          throw new Error(`Missing second argument. It must be a callback function.`);\n        }\n\n        if (typeof specDefinitions !== 'function') {\n          throw new Error(`Invalid second argument, ${specDefinitions}. It must be a callback function.`);\n        }\n\n        if (specDefinitions.length > 0) {\n          throw new Error('describe does not expect any arguments');\n        }\n\n        if (currentDeclarationSuite.markedPending) {\n          suite.pend();\n        }\n\n        if (currentDeclarationSuite.markedTodo) {\n          // @ts-expect-error TODO Possible error: Suite does not have todo method\n          suite.todo();\n        }\n\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      this.xdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.pend();\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      const focusedRunnables = [];\n\n      this.fdescribe = function (description, specDefinitions) {\n        const suite = suiteFactory(description);\n        suite.isFocused = true;\n        focusedRunnables.push(suite.id);\n        unfocusAncestor();\n        addSpecsToSuite(suite, specDefinitions);\n        return suite;\n      };\n\n      const addSpecsToSuite = (suite, specDefinitions) => {\n        const parentSuite = currentDeclarationSuite;\n        parentSuite.addChild(suite);\n        currentDeclarationSuite = suite;\n        let declarationError = undefined;\n        let describeReturnValue;\n\n        try {\n          describeReturnValue = specDefinitions.call(suite);\n        } catch (e) {\n          declarationError = e;\n        } // TODO throw in Jest 25: declarationError = new Error\n\n\n        if ((0, _jestUtil.isPromise)(describeReturnValue)) {\n          console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk.default.yellow('Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.\\n' + 'Returning a value from \"describe\" will fail the test in a future version of Jest.')), {\n            rootDir: '',\n            testMatch: []\n          }, {\n            noStackTrace: false\n          }));\n        } else if (describeReturnValue !== undefined) {\n          console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk.default.yellow('A \"describe\" callback must not return a value.\\n' + 'Returning a value from \"describe\" will fail the test in a future version of Jest.')), {\n            rootDir: '',\n            testMatch: []\n          }, {\n            noStackTrace: false\n          }));\n        }\n\n        if (declarationError) {\n          this.it('encountered a declaration exception', () => {\n            throw declarationError;\n          });\n        }\n\n        currentDeclarationSuite = parentSuite;\n      };\n\n      function findFocusedAncestor(suite) {\n        while (suite) {\n          if (suite.isFocused) {\n            return suite.id;\n          }\n\n          suite = suite.parentSuite;\n        }\n\n        return null;\n      }\n\n      function unfocusAncestor() {\n        const focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n\n        if (focusedAncestor) {\n          for (let i = 0; i < focusedRunnables.length; i++) {\n            if (focusedRunnables[i] === focusedAncestor) {\n              focusedRunnables.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      const specFactory = (description, fn, suite, timeout) => {\n        totalSpecsDefined++;\n        const spec = new j$.Spec({\n          id: getNextSpecId(),\n          beforeAndAfterFns: beforeAndAfterFns(suite),\n          resultCallback: specResultCallback,\n\n          getSpecName(spec) {\n            return getSpecName(spec, suite);\n          },\n\n          getTestPath() {\n            return j$.testPath;\n          },\n\n          onStart: specStarted,\n          description,\n          queueRunnerFactory,\n\n          userContext() {\n            return suite.clonedSharedUserContext();\n          },\n\n          queueableFn: {\n            fn,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n\n          },\n          throwOnExpectationFailure\n        });\n\n        if (!this.specFilter(spec)) {\n          spec.disable();\n        }\n\n        return spec;\n\n        function specResultCallback(result) {\n          clearResourcesForRunnable(spec.id);\n          currentSpec = null;\n          reporter.specDone(result);\n        }\n\n        function specStarted(spec) {\n          currentSpec = spec;\n          defaultResourcesForRunnable(spec.id, suite.id);\n          reporter.specStarted(spec.result);\n        }\n      };\n\n      this.it = function (description, fn, timeout) {\n        if (typeof description !== 'string') {\n          throw new Error(`Invalid first argument, ${description}. It must be a string.`);\n        }\n\n        if (fn === undefined) {\n          throw new Error('Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.');\n        }\n\n        if (typeof fn !== 'function') {\n          throw new Error(`Invalid second argument, ${fn}. It must be a callback function.`);\n        }\n\n        const spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n\n        if (currentDeclarationSuite.markedPending) {\n          spec.pend();\n        } // When a test is defined inside another, jasmine will not run it.\n        // This check throws an error to warn the user about the edge-case.\n\n\n        if (currentSpec !== null) {\n          throw new Error(`Tests cannot be nested. Test \"${spec.description}\" cannot run because it is nested within \"${currentSpec.description}\".`);\n        }\n\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.xit = function (...args) {\n        const spec = this.it.apply(this, args);\n        spec.pend('Temporarily disabled with xit');\n        return spec;\n      };\n\n      this.todo = function () {\n        const description = arguments[0];\n\n        if (arguments.length !== 1 || typeof description !== 'string') {\n          throw new _jestUtil.ErrorWithStack('Todo must be called with only a description.', this.todo);\n        }\n\n        const spec = specFactory(description, () => {}, currentDeclarationSuite);\n        spec.todo();\n        currentDeclarationSuite.addChild(spec);\n        return spec;\n      };\n\n      this.fit = function (description, fn, timeout) {\n        const spec = specFactory(description, fn, currentDeclarationSuite, timeout);\n        currentDeclarationSuite.addChild(spec);\n        focusedRunnables.push(spec.id);\n        unfocusAncestor();\n        return spec;\n      };\n\n      this.beforeEach = function (beforeEachFunction, timeout) {\n        currentDeclarationSuite.beforeEach({\n          fn: beforeEachFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.beforeAll = function (beforeAllFunction, timeout) {\n        currentDeclarationSuite.beforeAll({\n          fn: beforeAllFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.afterEach = function (afterEachFunction, timeout) {\n        currentDeclarationSuite.afterEach({\n          fn: afterEachFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.afterAll = function (afterAllFunction, timeout) {\n        currentDeclarationSuite.afterAll({\n          fn: afterAllFunction,\n\n          timeout() {\n            return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n          }\n\n        });\n      };\n\n      this.pending = function (message) {\n        let fullMessage = j$.Spec.pendingSpecExceptionMessage;\n\n        if (message) {\n          fullMessage += message;\n        }\n\n        throw fullMessage;\n      };\n\n      this.fail = function (error) {\n        let checkIsError;\n        let message;\n\n        if (error instanceof _assert.AssertionError || error && error.name === _assert.AssertionError.name) {\n          checkIsError = false; // @ts-expect-error TODO Possible error: j$.Spec does not have expand property\n\n          message = (0, _assertionErrorMessage.default)(error, {\n            expand: j$.Spec.expand\n          });\n        } else {\n          const check = (0, _isError.default)(error);\n          checkIsError = check.isError;\n          message = check.message;\n        }\n\n        const errorAsErrorObject = checkIsError ? error : new Error(message);\n        const runnable = currentRunnable();\n\n        if (!runnable) {\n          errorAsErrorObject.message = 'Caught error after test environment was torn down\\n\\n' + errorAsErrorObject.message;\n          throw errorAsErrorObject;\n        }\n\n        runnable.addExpectationResult(false, {\n          matcherName: '',\n          passed: false,\n          expected: '',\n          actual: '',\n          message,\n          error: errorAsErrorObject\n        });\n      };\n    }\n\n  }, _temp;\n}","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-jasmine2/build/jasmine/Env.js"],"names":["Object","defineProperty","exports","value","default","_default","_assert","require","_chalk","_interopRequireDefault","_jestMessageUtil","_jestUtil","_assertionErrorMessage","_isError","_queueRunner","_treeProcessor","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","j$","_temp","Env","constructor","_options","totalSpecsDefined","catchExceptions","realSetTimeout","global","setTimeout","realClearTimeout","clearTimeout","runnableResources","currentlyExecutingSuites","currentSpec","throwOnExpectationFailure","random","seed","nextSpecId","nextSuiteId","getNextSpecId","getNextSuiteId","topSuite","Suite","id","description","getTestPath","testPath","currentDeclarationSuite","currentSuite","length","currentRunnable","reporter","ReportDispatcher","specFilter","defaultResourcesForRunnable","_parentRunnableId","resources","spies","clearResourcesForRunnable","spyRegistry","clearSpies","beforeAndAfterFns","suite","afters","befores","concat","beforeFns","afterFns","parentSuite","reverse","getSpecName","spec","fullName","suiteFullName","getFullName","unshift","join","catchingExceptions","throwingExpectationFailures","randomizeTests","randomTests","queueRunnerFactory","options","fail","uncaught","err","onException","cancel","console","error","stack","oldListenersException","oldListenersRejection","executionSetup","process","listeners","slice","removeAllListeners","on","executionTeardown","removeListener","forEach","listener","execute","runnablesToRun","suiteTree","focusedRunnables","lastDeclarationSuite","nodeComplete","disabled","pop","jasmineDone","failedExpectations","result","suiteDone","getResult","nodeStart","push","jasmineStarted","suiteStarted","runnableIds","tree","addReporter","reporterToAdd","provideFallbackReporter","clearReporters","SpyRegistry","currentSpies","Error","allowRespy","allow","spyOn","args","apply","suiteFactory","describe","specDefinitions","undefined","markedPending","pend","markedTodo","todo","addSpecsToSuite","xdescribe","fdescribe","isFocused","unfocusAncestor","addChild","declarationError","describeReturnValue","call","e","isPromise","log","formatExecError","yellow","rootDir","testMatch","noStackTrace","it","findFocusedAncestor","focusedAncestor","i","splice","specFactory","fn","timeout","Spec","resultCallback","specResultCallback","onStart","specStarted","userContext","clonedSharedUserContext","queueableFn","_DEFAULT_TIMEOUT_INTERVAL","disable","specDone","xit","arguments","ErrorWithStack","fit","beforeEach","beforeEachFunction","beforeAll","beforeAllFunction","afterEach","afterEachFunction","afterAll","afterAllFunction","pending","message","fullMessage","pendingSpecExceptionMessage","checkIsError","AssertionError","name","expand","check","isError","errorAsErrorObject","runnable","addExpectationResult","matcherName","passed","expected","actual"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = _default;\n\nvar _assert = require('assert');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar _jestMessageUtil = require('jest-message-util');\n\nvar _jestUtil = require('jest-util');\n\nvar _assertionErrorMessage = _interopRequireDefault(\n  require('../assertionErrorMessage')\n);\n\nvar _isError = _interopRequireDefault(require('../isError'));\n\nvar _queueRunner = _interopRequireDefault(require('../queueRunner'));\n\nvar _treeProcessor = _interopRequireDefault(require('../treeProcessor'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction _default(j$) {\n  var _temp;\n\n  return (\n    (_temp = class Env {\n      constructor(_options) {\n        _defineProperty(this, 'specFilter', void 0);\n\n        _defineProperty(this, 'catchExceptions', void 0);\n\n        _defineProperty(this, 'throwOnExpectationFailure', void 0);\n\n        _defineProperty(this, 'catchingExceptions', void 0);\n\n        _defineProperty(this, 'topSuite', void 0);\n\n        _defineProperty(this, 'fail', void 0);\n\n        _defineProperty(this, 'pending', void 0);\n\n        _defineProperty(this, 'afterAll', void 0);\n\n        _defineProperty(this, 'fit', void 0);\n\n        _defineProperty(this, 'throwingExpectationFailures', void 0);\n\n        _defineProperty(this, 'randomizeTests', void 0);\n\n        _defineProperty(this, 'randomTests', void 0);\n\n        _defineProperty(this, 'seed', void 0);\n\n        _defineProperty(this, 'execute', void 0);\n\n        _defineProperty(this, 'fdescribe', void 0);\n\n        _defineProperty(this, 'spyOn', void 0);\n\n        _defineProperty(this, 'beforeEach', void 0);\n\n        _defineProperty(this, 'afterEach', void 0);\n\n        _defineProperty(this, 'clearReporters', void 0);\n\n        _defineProperty(this, 'addReporter', void 0);\n\n        _defineProperty(this, 'it', void 0);\n\n        _defineProperty(this, 'xdescribe', void 0);\n\n        _defineProperty(this, 'xit', void 0);\n\n        _defineProperty(this, 'beforeAll', void 0);\n\n        _defineProperty(this, 'todo', void 0);\n\n        _defineProperty(this, 'provideFallbackReporter', void 0);\n\n        _defineProperty(this, 'allowRespy', void 0);\n\n        _defineProperty(this, 'describe', void 0);\n\n        let totalSpecsDefined = 0;\n        let catchExceptions = true;\n        const realSetTimeout = global.setTimeout;\n        const realClearTimeout = global.clearTimeout;\n        const runnableResources = {};\n        const currentlyExecutingSuites = [];\n        let currentSpec = null;\n        let throwOnExpectationFailure = false;\n        let random = false;\n        let seed = null;\n        let nextSpecId = 0;\n        let nextSuiteId = 0;\n\n        const getNextSpecId = function () {\n          return 'spec' + nextSpecId++;\n        };\n\n        const getNextSuiteId = function () {\n          return 'suite' + nextSuiteId++;\n        };\n\n        const topSuite = new j$.Suite({\n          id: getNextSuiteId(),\n          description: '',\n\n          getTestPath() {\n            return j$.testPath;\n          }\n        });\n        let currentDeclarationSuite = topSuite;\n\n        const currentSuite = function () {\n          return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\n        };\n\n        const currentRunnable = function () {\n          return currentSpec || currentSuite();\n        };\n\n        const reporter = new j$.ReportDispatcher([\n          'jasmineStarted',\n          'jasmineDone',\n          'suiteStarted',\n          'suiteDone',\n          'specStarted',\n          'specDone'\n        ]);\n\n        this.specFilter = function () {\n          return true;\n        };\n\n        const defaultResourcesForRunnable = function (id, _parentRunnableId) {\n          const resources = {\n            spies: []\n          };\n          runnableResources[id] = resources;\n        };\n\n        const clearResourcesForRunnable = function (id) {\n          spyRegistry.clearSpies();\n          delete runnableResources[id];\n        };\n\n        const beforeAndAfterFns = function (suite) {\n          return function () {\n            let afters = [];\n            let befores = [];\n\n            while (suite) {\n              befores = befores.concat(suite.beforeFns);\n              afters = afters.concat(suite.afterFns);\n              suite = suite.parentSuite;\n            }\n\n            return {\n              befores: befores.reverse(),\n              afters\n            };\n          };\n        };\n\n        const getSpecName = function (spec, suite) {\n          const fullName = [spec.description];\n          const suiteFullName = suite.getFullName();\n\n          if (suiteFullName !== '') {\n            fullName.unshift(suiteFullName);\n          }\n\n          return fullName.join(' ');\n        };\n\n        this.catchExceptions = function (value) {\n          catchExceptions = !!value;\n          return catchExceptions;\n        };\n\n        this.catchingExceptions = function () {\n          return catchExceptions;\n        };\n\n        this.throwOnExpectationFailure = function (value) {\n          throwOnExpectationFailure = !!value;\n        };\n\n        this.throwingExpectationFailures = function () {\n          return throwOnExpectationFailure;\n        };\n\n        this.randomizeTests = function (value) {\n          random = !!value;\n        };\n\n        this.randomTests = function () {\n          return random;\n        };\n\n        this.seed = function (value) {\n          if (value) {\n            seed = value;\n          }\n\n          return seed;\n        };\n\n        const queueRunnerFactory = options => {\n          options.clearTimeout = realClearTimeout;\n          options.fail = this.fail;\n          options.setTimeout = realSetTimeout;\n          return (0, _queueRunner.default)(options);\n        };\n\n        this.topSuite = function () {\n          return topSuite;\n        };\n\n        const uncaught = err => {\n          if (currentSpec) {\n            currentSpec.onException(err);\n            currentSpec.cancel();\n          } else {\n            console.error('Unhandled error');\n            console.error(err.stack);\n          }\n        };\n\n        let oldListenersException;\n        let oldListenersRejection;\n\n        const executionSetup = function () {\n          // Need to ensure we are the only ones handling these exceptions.\n          oldListenersException = process\n            .listeners('uncaughtException')\n            .slice();\n          oldListenersRejection = process\n            .listeners('unhandledRejection')\n            .slice();\n          j$.process.removeAllListeners('uncaughtException');\n          j$.process.removeAllListeners('unhandledRejection');\n          j$.process.on('uncaughtException', uncaught);\n          j$.process.on('unhandledRejection', uncaught);\n        };\n\n        const executionTeardown = function () {\n          j$.process.removeListener('uncaughtException', uncaught);\n          j$.process.removeListener('unhandledRejection', uncaught); // restore previous exception handlers\n\n          oldListenersException.forEach(listener => {\n            j$.process.on('uncaughtException', listener);\n          });\n          oldListenersRejection.forEach(listener => {\n            j$.process.on('unhandledRejection', listener);\n          });\n        };\n\n        this.execute = async function (runnablesToRun, suiteTree = topSuite) {\n          if (!runnablesToRun) {\n            if (focusedRunnables.length) {\n              runnablesToRun = focusedRunnables;\n            } else {\n              runnablesToRun = [suiteTree.id];\n            }\n          }\n\n          if (currentlyExecutingSuites.length === 0) {\n            executionSetup();\n          }\n\n          const lastDeclarationSuite = currentDeclarationSuite;\n          await (0, _treeProcessor.default)({\n            nodeComplete(suite) {\n              if (!suite.disabled) {\n                clearResourcesForRunnable(suite.id);\n              }\n\n              currentlyExecutingSuites.pop();\n\n              if (suite === topSuite) {\n                reporter.jasmineDone({\n                  failedExpectations: topSuite.result.failedExpectations\n                });\n              } else {\n                reporter.suiteDone(suite.getResult());\n              }\n            },\n\n            nodeStart(suite) {\n              currentlyExecutingSuites.push(suite);\n              defaultResourcesForRunnable(\n                suite.id,\n                suite.parentSuite && suite.parentSuite.id\n              );\n\n              if (suite === topSuite) {\n                reporter.jasmineStarted({\n                  totalSpecsDefined\n                });\n              } else {\n                reporter.suiteStarted(suite.result);\n              }\n            },\n\n            queueRunnerFactory,\n            runnableIds: runnablesToRun,\n            tree: suiteTree\n          });\n          currentDeclarationSuite = lastDeclarationSuite;\n\n          if (currentlyExecutingSuites.length === 0) {\n            executionTeardown();\n          }\n        };\n\n        this.addReporter = function (reporterToAdd) {\n          reporter.addReporter(reporterToAdd);\n        };\n\n        this.provideFallbackReporter = function (reporterToAdd) {\n          reporter.provideFallbackReporter(reporterToAdd);\n        };\n\n        this.clearReporters = function () {\n          reporter.clearReporters();\n        };\n\n        const spyRegistry = new j$.SpyRegistry({\n          currentSpies() {\n            if (!currentRunnable()) {\n              throw new Error(\n                'Spies must be created in a before function or a spec'\n              );\n            }\n\n            return runnableResources[currentRunnable().id].spies;\n          }\n        });\n\n        this.allowRespy = function (allow) {\n          spyRegistry.allowRespy(allow);\n        };\n\n        this.spyOn = function (...args) {\n          return spyRegistry.spyOn.apply(spyRegistry, args);\n        };\n\n        const suiteFactory = function (description) {\n          const suite = new j$.Suite({\n            id: getNextSuiteId(),\n            description,\n            parentSuite: currentDeclarationSuite,\n            throwOnExpectationFailure,\n\n            getTestPath() {\n              return j$.testPath;\n            }\n          });\n          return suite;\n        };\n\n        this.describe = function (description, specDefinitions) {\n          const suite = suiteFactory(description);\n\n          if (specDefinitions === undefined) {\n            throw new Error(\n              `Missing second argument. It must be a callback function.`\n            );\n          }\n\n          if (typeof specDefinitions !== 'function') {\n            throw new Error(\n              `Invalid second argument, ${specDefinitions}. It must be a callback function.`\n            );\n          }\n\n          if (specDefinitions.length > 0) {\n            throw new Error('describe does not expect any arguments');\n          }\n\n          if (currentDeclarationSuite.markedPending) {\n            suite.pend();\n          }\n\n          if (currentDeclarationSuite.markedTodo) {\n            // @ts-expect-error TODO Possible error: Suite does not have todo method\n            suite.todo();\n          }\n\n          addSpecsToSuite(suite, specDefinitions);\n          return suite;\n        };\n\n        this.xdescribe = function (description, specDefinitions) {\n          const suite = suiteFactory(description);\n          suite.pend();\n          addSpecsToSuite(suite, specDefinitions);\n          return suite;\n        };\n\n        const focusedRunnables = [];\n\n        this.fdescribe = function (description, specDefinitions) {\n          const suite = suiteFactory(description);\n          suite.isFocused = true;\n          focusedRunnables.push(suite.id);\n          unfocusAncestor();\n          addSpecsToSuite(suite, specDefinitions);\n          return suite;\n        };\n\n        const addSpecsToSuite = (suite, specDefinitions) => {\n          const parentSuite = currentDeclarationSuite;\n          parentSuite.addChild(suite);\n          currentDeclarationSuite = suite;\n          let declarationError = undefined;\n          let describeReturnValue;\n\n          try {\n            describeReturnValue = specDefinitions.call(suite);\n          } catch (e) {\n            declarationError = e;\n          } // TODO throw in Jest 25: declarationError = new Error\n\n          if ((0, _jestUtil.isPromise)(describeReturnValue)) {\n            console.log(\n              (0, _jestMessageUtil.formatExecError)(\n                new Error(\n                  _chalk.default.yellow(\n                    'Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.\\n' +\n                      'Returning a value from \"describe\" will fail the test in a future version of Jest.'\n                  )\n                ),\n                {\n                  rootDir: '',\n                  testMatch: []\n                },\n                {\n                  noStackTrace: false\n                }\n              )\n            );\n          } else if (describeReturnValue !== undefined) {\n            console.log(\n              (0, _jestMessageUtil.formatExecError)(\n                new Error(\n                  _chalk.default.yellow(\n                    'A \"describe\" callback must not return a value.\\n' +\n                      'Returning a value from \"describe\" will fail the test in a future version of Jest.'\n                  )\n                ),\n                {\n                  rootDir: '',\n                  testMatch: []\n                },\n                {\n                  noStackTrace: false\n                }\n              )\n            );\n          }\n\n          if (declarationError) {\n            this.it('encountered a declaration exception', () => {\n              throw declarationError;\n            });\n          }\n\n          currentDeclarationSuite = parentSuite;\n        };\n\n        function findFocusedAncestor(suite) {\n          while (suite) {\n            if (suite.isFocused) {\n              return suite.id;\n            }\n\n            suite = suite.parentSuite;\n          }\n\n          return null;\n        }\n\n        function unfocusAncestor() {\n          const focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\n\n          if (focusedAncestor) {\n            for (let i = 0; i < focusedRunnables.length; i++) {\n              if (focusedRunnables[i] === focusedAncestor) {\n                focusedRunnables.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n\n        const specFactory = (description, fn, suite, timeout) => {\n          totalSpecsDefined++;\n          const spec = new j$.Spec({\n            id: getNextSpecId(),\n            beforeAndAfterFns: beforeAndAfterFns(suite),\n            resultCallback: specResultCallback,\n\n            getSpecName(spec) {\n              return getSpecName(spec, suite);\n            },\n\n            getTestPath() {\n              return j$.testPath;\n            },\n\n            onStart: specStarted,\n            description,\n            queueRunnerFactory,\n\n            userContext() {\n              return suite.clonedSharedUserContext();\n            },\n\n            queueableFn: {\n              fn,\n\n              timeout() {\n                return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n              }\n            },\n            throwOnExpectationFailure\n          });\n\n          if (!this.specFilter(spec)) {\n            spec.disable();\n          }\n\n          return spec;\n\n          function specResultCallback(result) {\n            clearResourcesForRunnable(spec.id);\n            currentSpec = null;\n            reporter.specDone(result);\n          }\n\n          function specStarted(spec) {\n            currentSpec = spec;\n            defaultResourcesForRunnable(spec.id, suite.id);\n            reporter.specStarted(spec.result);\n          }\n        };\n\n        this.it = function (description, fn, timeout) {\n          if (typeof description !== 'string') {\n            throw new Error(\n              `Invalid first argument, ${description}. It must be a string.`\n            );\n          }\n\n          if (fn === undefined) {\n            throw new Error(\n              'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.'\n            );\n          }\n\n          if (typeof fn !== 'function') {\n            throw new Error(\n              `Invalid second argument, ${fn}. It must be a callback function.`\n            );\n          }\n\n          const spec = specFactory(\n            description,\n            fn,\n            currentDeclarationSuite,\n            timeout\n          );\n\n          if (currentDeclarationSuite.markedPending) {\n            spec.pend();\n          } // When a test is defined inside another, jasmine will not run it.\n          // This check throws an error to warn the user about the edge-case.\n\n          if (currentSpec !== null) {\n            throw new Error(\n              `Tests cannot be nested. Test \"${spec.description}\" cannot run because it is nested within \"${currentSpec.description}\".`\n            );\n          }\n\n          currentDeclarationSuite.addChild(spec);\n          return spec;\n        };\n\n        this.xit = function (...args) {\n          const spec = this.it.apply(this, args);\n          spec.pend('Temporarily disabled with xit');\n          return spec;\n        };\n\n        this.todo = function () {\n          const description = arguments[0];\n\n          if (arguments.length !== 1 || typeof description !== 'string') {\n            throw new _jestUtil.ErrorWithStack(\n              'Todo must be called with only a description.',\n              this.todo\n            );\n          }\n\n          const spec = specFactory(\n            description,\n            () => {},\n            currentDeclarationSuite\n          );\n          spec.todo();\n          currentDeclarationSuite.addChild(spec);\n          return spec;\n        };\n\n        this.fit = function (description, fn, timeout) {\n          const spec = specFactory(\n            description,\n            fn,\n            currentDeclarationSuite,\n            timeout\n          );\n          currentDeclarationSuite.addChild(spec);\n          focusedRunnables.push(spec.id);\n          unfocusAncestor();\n          return spec;\n        };\n\n        this.beforeEach = function (beforeEachFunction, timeout) {\n          currentDeclarationSuite.beforeEach({\n            fn: beforeEachFunction,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n          });\n        };\n\n        this.beforeAll = function (beforeAllFunction, timeout) {\n          currentDeclarationSuite.beforeAll({\n            fn: beforeAllFunction,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n          });\n        };\n\n        this.afterEach = function (afterEachFunction, timeout) {\n          currentDeclarationSuite.afterEach({\n            fn: afterEachFunction,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n          });\n        };\n\n        this.afterAll = function (afterAllFunction, timeout) {\n          currentDeclarationSuite.afterAll({\n            fn: afterAllFunction,\n\n            timeout() {\n              return timeout || j$._DEFAULT_TIMEOUT_INTERVAL;\n            }\n          });\n        };\n\n        this.pending = function (message) {\n          let fullMessage = j$.Spec.pendingSpecExceptionMessage;\n\n          if (message) {\n            fullMessage += message;\n          }\n\n          throw fullMessage;\n        };\n\n        this.fail = function (error) {\n          let checkIsError;\n          let message;\n\n          if (\n            error instanceof _assert.AssertionError ||\n            (error && error.name === _assert.AssertionError.name)\n          ) {\n            checkIsError = false; // @ts-expect-error TODO Possible error: j$.Spec does not have expand property\n\n            message = (0, _assertionErrorMessage.default)(error, {\n              expand: j$.Spec.expand\n            });\n          } else {\n            const check = (0, _isError.default)(error);\n            checkIsError = check.isError;\n            message = check.message;\n          }\n\n          const errorAsErrorObject = checkIsError ? error : new Error(message);\n          const runnable = currentRunnable();\n\n          if (!runnable) {\n            errorAsErrorObject.message =\n              'Caught error after test environment was torn down\\n\\n' +\n              errorAsErrorObject.message;\n            throw errorAsErrorObject;\n          }\n\n          runnable.addExpectationResult(false, {\n            matcherName: '',\n            passed: false,\n            expected: '',\n            actual: '',\n            message,\n            error: errorAsErrorObject\n          });\n        };\n      }\n    }),\n    _temp\n  );\n}\n"]},"metadata":{},"sourceType":"script"}