{"ast":null,"code":"'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\n * DependencyResolver is used to resolve the direct dependencies of a module or\n * to retrieve a list of all transitive inverse dependencies.\n */\n\n\nclass DependencyResolver {\n  constructor(resolver, hasteFS, snapshotResolver) {\n    _defineProperty(this, '_hasteFS', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_snapshotResolver', void 0);\n\n    this._resolver = resolver;\n    this._hasteFS = hasteFS;\n    this._snapshotResolver = snapshotResolver;\n  }\n\n  resolve(file, options) {\n    const dependencies = this._hasteFS.getDependencies(file);\n\n    if (!dependencies) {\n      return [];\n    }\n\n    return dependencies.reduce((acc, dependency) => {\n      if (this._resolver.isCoreModule(dependency)) {\n        return acc;\n      }\n\n      let resolvedDependency;\n      let resolvedMockDependency;\n\n      try {\n        resolvedDependency = this._resolver.resolveModule(file, dependency, options);\n      } catch {\n        try {\n          resolvedDependency = this._resolver.getMockModule(file, dependency);\n        } catch {// leave resolvedDependency as undefined if nothing can be found\n        }\n      }\n\n      if (!resolvedDependency) {\n        return acc;\n      }\n\n      acc.push(resolvedDependency); // If we resolve a dependency, then look for a mock dependency\n      // of the same name in that dependency's directory.\n\n      try {\n        resolvedMockDependency = this._resolver.getMockModule(resolvedDependency, path().basename(dependency));\n      } catch {// leave resolvedMockDependency as undefined if nothing can be found\n      }\n\n      if (resolvedMockDependency) {\n        const dependencyMockDir = path().resolve(path().dirname(resolvedDependency), '__mocks__');\n        resolvedMockDependency = path().resolve(resolvedMockDependency); // make sure mock is in the correct directory\n\n        if (dependencyMockDir === path().dirname(resolvedMockDependency)) {\n          acc.push(resolvedMockDependency);\n        }\n      }\n\n      return acc;\n    }, []);\n  }\n\n  resolveInverseModuleMap(paths, filter, options) {\n    if (!paths.size) {\n      return [];\n    }\n\n    const collectModules = (related, moduleMap, changed) => {\n      const visitedModules = new Set();\n      const result = [];\n\n      while (changed.size) {\n        changed = new Set(moduleMap.reduce((acc, module) => {\n          if (visitedModules.has(module.file) || !module.dependencies.some(dep => changed.has(dep))) {\n            return acc;\n          }\n\n          const file = module.file;\n\n          if (filter(file)) {\n            result.push(module);\n            related.delete(file);\n          }\n\n          visitedModules.add(file);\n          acc.push(file);\n          return acc;\n        }, []));\n      }\n\n      return result.concat(Array.from(related).map(file => ({\n        dependencies: [],\n        file\n      })));\n    };\n\n    const relatedPaths = new Set();\n    const changed = new Set();\n\n    for (const path of paths) {\n      if (this._hasteFS.exists(path)) {\n        const modulePath = (0, _jestSnapshot().isSnapshotPath)(path) ? this._snapshotResolver.resolveTestPath(path) : path;\n        changed.add(modulePath);\n\n        if (filter(modulePath)) {\n          relatedPaths.add(modulePath);\n        }\n      }\n    }\n\n    const modules = [];\n\n    for (const file of this._hasteFS.getAbsoluteFileIterator()) {\n      modules.push({\n        dependencies: this.resolve(file, options),\n        file\n      });\n    }\n\n    return collectModules(relatedPaths, modules, changed);\n  }\n\n  resolveInverse(paths, filter, options) {\n    return this.resolveInverseModuleMap(paths, filter, options).map(module => module.file);\n  }\n\n}\n\nmodule.exports = DependencyResolver;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-resolve-dependencies/build/index.js"],"names":["path","data","_interopRequireWildcard","require","_jestSnapshot","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","default","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","value","enumerable","configurable","writable","DependencyResolver","constructor","resolver","hasteFS","snapshotResolver","_resolver","_hasteFS","_snapshotResolver","resolve","file","options","dependencies","getDependencies","reduce","acc","dependency","isCoreModule","resolvedDependency","resolvedMockDependency","resolveModule","getMockModule","push","basename","dependencyMockDir","dirname","resolveInverseModuleMap","paths","filter","size","collectModules","related","moduleMap","changed","visitedModules","Set","result","module","some","dep","delete","add","concat","Array","from","map","relatedPaths","exists","modulePath","isSnapshotPath","resolveTestPath","modules","getAbsoluteFileIterator","resolveInverse","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * DependencyResolver is used to resolve the direct dependencies of a module or\n * to retrieve a list of all transitive inverse dependencies.\n */\nclass DependencyResolver {\n  constructor(resolver, hasteFS, snapshotResolver) {\n    _defineProperty(this, '_hasteFS', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_snapshotResolver', void 0);\n\n    this._resolver = resolver;\n    this._hasteFS = hasteFS;\n    this._snapshotResolver = snapshotResolver;\n  }\n\n  resolve(file, options) {\n    const dependencies = this._hasteFS.getDependencies(file);\n\n    if (!dependencies) {\n      return [];\n    }\n\n    return dependencies.reduce((acc, dependency) => {\n      if (this._resolver.isCoreModule(dependency)) {\n        return acc;\n      }\n\n      let resolvedDependency;\n      let resolvedMockDependency;\n\n      try {\n        resolvedDependency = this._resolver.resolveModule(\n          file,\n          dependency,\n          options\n        );\n      } catch {\n        try {\n          resolvedDependency = this._resolver.getMockModule(file, dependency);\n        } catch {\n          // leave resolvedDependency as undefined if nothing can be found\n        }\n      }\n\n      if (!resolvedDependency) {\n        return acc;\n      }\n\n      acc.push(resolvedDependency); // If we resolve a dependency, then look for a mock dependency\n      // of the same name in that dependency's directory.\n\n      try {\n        resolvedMockDependency = this._resolver.getMockModule(\n          resolvedDependency,\n          path().basename(dependency)\n        );\n      } catch {\n        // leave resolvedMockDependency as undefined if nothing can be found\n      }\n\n      if (resolvedMockDependency) {\n        const dependencyMockDir = path().resolve(\n          path().dirname(resolvedDependency),\n          '__mocks__'\n        );\n        resolvedMockDependency = path().resolve(resolvedMockDependency); // make sure mock is in the correct directory\n\n        if (dependencyMockDir === path().dirname(resolvedMockDependency)) {\n          acc.push(resolvedMockDependency);\n        }\n      }\n\n      return acc;\n    }, []);\n  }\n\n  resolveInverseModuleMap(paths, filter, options) {\n    if (!paths.size) {\n      return [];\n    }\n\n    const collectModules = (related, moduleMap, changed) => {\n      const visitedModules = new Set();\n      const result = [];\n\n      while (changed.size) {\n        changed = new Set(\n          moduleMap.reduce((acc, module) => {\n            if (\n              visitedModules.has(module.file) ||\n              !module.dependencies.some(dep => changed.has(dep))\n            ) {\n              return acc;\n            }\n\n            const file = module.file;\n\n            if (filter(file)) {\n              result.push(module);\n              related.delete(file);\n            }\n\n            visitedModules.add(file);\n            acc.push(file);\n            return acc;\n          }, [])\n        );\n      }\n\n      return result.concat(\n        Array.from(related).map(file => ({\n          dependencies: [],\n          file\n        }))\n      );\n    };\n\n    const relatedPaths = new Set();\n    const changed = new Set();\n\n    for (const path of paths) {\n      if (this._hasteFS.exists(path)) {\n        const modulePath = (0, _jestSnapshot().isSnapshotPath)(path)\n          ? this._snapshotResolver.resolveTestPath(path)\n          : path;\n        changed.add(modulePath);\n\n        if (filter(modulePath)) {\n          relatedPaths.add(modulePath);\n        }\n      }\n    }\n\n    const modules = [];\n\n    for (const file of this._hasteFS.getAbsoluteFileIterator()) {\n      modules.push({\n        dependencies: this.resolve(file, options),\n        file\n      });\n    }\n\n    return collectModules(relatedPaths, modules, changed);\n  }\n\n  resolveInverse(paths, filter, options) {\n    return this.resolveInverseModuleMap(paths, filter, options).map(\n      module => module.file\n    );\n  }\n}\n\nmodule.exports = DependencyResolver;\n"]},"metadata":{},"sourceType":"script"}