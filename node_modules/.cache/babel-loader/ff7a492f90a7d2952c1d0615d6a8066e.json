{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = readConfigFileAndSetRootDir;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = require('./constants');\n\nvar _jsonlint = _interopRequireDefault(require('./vendor/jsonlint'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: vendored\n// Read the configuration and set its `rootDir`\n// 1. If it's a `package.json` file, we look into its \"jest\" property\n// 2. If it's a `jest.config.ts` file, we use `ts-node` to transpile & require it\n// 3. For any other file, we just require it. If we receive an 'ERR_REQUIRE_ESM'\n//    from node, perform a dynamic import instead.\n\n\nasync function readConfigFileAndSetRootDir(configPath) {\n  const isTS = configPath.endsWith(_constants.JEST_CONFIG_EXT_TS);\n  const isJSON = configPath.endsWith(_constants.JEST_CONFIG_EXT_JSON);\n  let configObject;\n\n  try {\n    if (isTS) {\n      configObject = await loadTSConfigFile(configPath);\n    } else {\n      configObject = require(configPath);\n    }\n  } catch (error) {\n    if (error.code === 'ERR_REQUIRE_ESM') {\n      try {\n        const configUrl = (0, _url().pathToFileURL)(configPath); // node `import()` supports URL, but TypeScript doesn't know that\n\n        const importedConfig = await import(configUrl.href);\n\n        if (!importedConfig.default) {\n          throw new Error(`Jest: Failed to load mjs config file ${configPath} - did you use a default export?`);\n        }\n\n        configObject = importedConfig.default;\n      } catch (innerError) {\n        if (innerError.message === 'Not supported') {\n          throw new Error(`Jest: Your version of Node does not support dynamic import - please enable it or use a .cjs file extension for file ${configPath}`);\n        }\n\n        throw innerError;\n      }\n    } else if (isJSON) {\n      throw new Error(`Jest: Failed to parse config file ${configPath}\\n` + `  ${_jsonlint.default.errors(fs().readFileSync(configPath, 'utf8'))}`);\n    } else if (isTS) {\n      throw new Error(`Jest: Failed to parse the TypeScript config file ${configPath}\\n` + `  ${error}`);\n    } else {\n      throw error;\n    }\n  }\n\n  if (configPath.endsWith(_constants.PACKAGE_JSON)) {\n    // Event if there's no \"jest\" property in package.json we will still use\n    // an empty object.\n    configObject = configObject.jest || {};\n  }\n\n  if (configObject.rootDir) {\n    // We don't touch it if it has an absolute path specified\n    if (!path().isAbsolute(configObject.rootDir)) {\n      // otherwise, we'll resolve it relative to the file's __dirname\n      configObject.rootDir = path().resolve(path().dirname(configPath), configObject.rootDir);\n    }\n  } else {\n    // If rootDir is not there, we'll set it to this file's __dirname\n    configObject.rootDir = path().dirname(configPath);\n  }\n\n  return configObject;\n} // Load the TypeScript configuration\n\n\nconst loadTSConfigFile = async configPath => {\n  let registerer; // Register TypeScript compiler instance\n\n  try {\n    registerer = require('ts-node').register({\n      compilerOptions: {\n        module: 'CommonJS'\n      }\n    });\n  } catch (e) {\n    if (e.code === 'MODULE_NOT_FOUND') {\n      throw new Error(`Jest: 'ts-node' is required for the TypeScript configuration files. Make sure it is installed\\nError: ${e.message}`);\n    }\n\n    throw e;\n  }\n\n  registerer.enabled(true);\n  let configObject = (0, _jestUtil().interopRequireDefault)(require(configPath)).default; // In case the config is a function which imports more Typescript code\n\n  if (typeof configObject === 'function') {\n    configObject = await configObject();\n  }\n\n  registerer.enabled(false);\n  return configObject;\n};","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-config/build/readConfigFileAndSetRootDir.js"],"names":["Object","defineProperty","exports","value","default","readConfigFileAndSetRootDir","path","data","_interopRequireWildcard","require","_url","fs","_jestUtil","_constants","_jsonlint","_interopRequireDefault","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","configPath","isTS","endsWith","JEST_CONFIG_EXT_TS","isJSON","JEST_CONFIG_EXT_JSON","configObject","loadTSConfigFile","error","code","configUrl","pathToFileURL","importedConfig","href","Error","innerError","message","errors","readFileSync","PACKAGE_JSON","jest","rootDir","isAbsolute","resolve","dirname","registerer","register","compilerOptions","module","e","enabled","interopRequireDefault"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = readConfigFileAndSetRootDir;\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _constants = require('./constants');\n\nvar _jsonlint = _interopRequireDefault(require('./vendor/jsonlint'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// @ts-expect-error: vendored\n// Read the configuration and set its `rootDir`\n// 1. If it's a `package.json` file, we look into its \"jest\" property\n// 2. If it's a `jest.config.ts` file, we use `ts-node` to transpile & require it\n// 3. For any other file, we just require it. If we receive an 'ERR_REQUIRE_ESM'\n//    from node, perform a dynamic import instead.\nasync function readConfigFileAndSetRootDir(configPath) {\n  const isTS = configPath.endsWith(_constants.JEST_CONFIG_EXT_TS);\n  const isJSON = configPath.endsWith(_constants.JEST_CONFIG_EXT_JSON);\n  let configObject;\n\n  try {\n    if (isTS) {\n      configObject = await loadTSConfigFile(configPath);\n    } else {\n      configObject = require(configPath);\n    }\n  } catch (error) {\n    if (error.code === 'ERR_REQUIRE_ESM') {\n      try {\n        const configUrl = (0, _url().pathToFileURL)(configPath); // node `import()` supports URL, but TypeScript doesn't know that\n\n        const importedConfig = await import(configUrl.href);\n\n        if (!importedConfig.default) {\n          throw new Error(\n            `Jest: Failed to load mjs config file ${configPath} - did you use a default export?`\n          );\n        }\n\n        configObject = importedConfig.default;\n      } catch (innerError) {\n        if (innerError.message === 'Not supported') {\n          throw new Error(\n            `Jest: Your version of Node does not support dynamic import - please enable it or use a .cjs file extension for file ${configPath}`\n          );\n        }\n\n        throw innerError;\n      }\n    } else if (isJSON) {\n      throw new Error(\n        `Jest: Failed to parse config file ${configPath}\\n` +\n          `  ${_jsonlint.default.errors(fs().readFileSync(configPath, 'utf8'))}`\n      );\n    } else if (isTS) {\n      throw new Error(\n        `Jest: Failed to parse the TypeScript config file ${configPath}\\n` +\n          `  ${error}`\n      );\n    } else {\n      throw error;\n    }\n  }\n\n  if (configPath.endsWith(_constants.PACKAGE_JSON)) {\n    // Event if there's no \"jest\" property in package.json we will still use\n    // an empty object.\n    configObject = configObject.jest || {};\n  }\n\n  if (configObject.rootDir) {\n    // We don't touch it if it has an absolute path specified\n    if (!path().isAbsolute(configObject.rootDir)) {\n      // otherwise, we'll resolve it relative to the file's __dirname\n      configObject.rootDir = path().resolve(\n        path().dirname(configPath),\n        configObject.rootDir\n      );\n    }\n  } else {\n    // If rootDir is not there, we'll set it to this file's __dirname\n    configObject.rootDir = path().dirname(configPath);\n  }\n\n  return configObject;\n} // Load the TypeScript configuration\n\nconst loadTSConfigFile = async configPath => {\n  let registerer; // Register TypeScript compiler instance\n\n  try {\n    registerer = require('ts-node').register({\n      compilerOptions: {\n        module: 'CommonJS'\n      }\n    });\n  } catch (e) {\n    if (e.code === 'MODULE_NOT_FOUND') {\n      throw new Error(\n        `Jest: 'ts-node' is required for the TypeScript configuration files. Make sure it is installed\\nError: ${e.message}`\n      );\n    }\n\n    throw e;\n  }\n\n  registerer.enabled(true);\n  let configObject = (0, _jestUtil().interopRequireDefault)(require(configPath))\n    .default; // In case the config is a function which imports more Typescript code\n\n  if (typeof configObject === 'function') {\n    configObject = await configObject();\n  }\n\n  registerer.enabled(false);\n  return configObject;\n};\n"]},"metadata":{},"sourceType":"script"}