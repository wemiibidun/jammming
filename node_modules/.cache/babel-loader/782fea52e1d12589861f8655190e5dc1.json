{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceCoverage = void 0;\n\nvar _istanbulLibCoverage = require(\"istanbul-lib-coverage\");\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nclass SourceCoverage extends _istanbulLibCoverage.classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n\n  newBranch(type, loc) {\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    return b;\n  }\n\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n    /* istanbul ignore if: paranoid check */\n\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    return counts.length - 1;\n  }\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n\n\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n      }\n    });\n  }\n\n}\n\nexports.SourceCoverage = SourceCoverage;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/istanbul-lib-instrument/dist/source-coverage.js"],"names":["Object","defineProperty","exports","value","SourceCoverage","_istanbulLibCoverage","require","cloneLocation","loc","start","line","column","end","classes","FileCoverage","constructor","pathOrObj","meta","last","s","f","b","newStatement","data","statementMap","newFunction","name","decl","fnMap","newBranch","type","branchMap","locations","addBranchPath","location","bMeta","counts","Error","push","length","inputSourceMap","sourceMap","freeze","map","branches","keys","forEach"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceCoverage = void 0;\n\nvar _istanbulLibCoverage = require(\"istanbul-lib-coverage\");\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nclass SourceCoverage extends _istanbulLibCoverage.classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n\n  newBranch(type, loc) {\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    return b;\n  }\n\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n    /* istanbul ignore if: paranoid check */\n\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    return counts.length - 1;\n  }\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n\n\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n      }\n    });\n  }\n\n}\n\nexports.SourceCoverage = SourceCoverage;"]},"metadata":{},"sourceType":"script"}