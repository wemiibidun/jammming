{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _CallTracker = _interopRequireDefault(require('./CallTracker'));\n\nvar _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));\n\nvar _createSpy = _interopRequireDefault(require('./createSpy'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst formatErrorMsg = (domain, usage) => {\n  const usageDefinition = usage ? '\\nUsage: ' + usage : '';\n  return msg => domain + ' : ' + msg + usageDefinition;\n};\n\nfunction isSpy(putativeSpy) {\n  if (!putativeSpy) {\n    return false;\n  }\n\n  return putativeSpy.and instanceof _SpyStrategy.default && putativeSpy.calls instanceof _CallTracker.default;\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nclass SpyRegistry {\n  constructor({\n    currentSpies = () => []\n  } = {}) {\n    _defineProperty(this, 'allowRespy', void 0);\n\n    _defineProperty(this, 'spyOn', void 0);\n\n    _defineProperty(this, 'clearSpies', void 0);\n\n    _defineProperty(this, 'respy', void 0);\n\n    _defineProperty(this, '_spyOnProperty', void 0);\n\n    this.allowRespy = function (allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\n        }\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function () {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function () {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      obj[methodName] = spiedMethod;\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(getErrorMsg('could not find an object to spy upon for ' + propertyName));\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch {// IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(propertyName + ' property does not exist'));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(getErrorMsg(propertyName + ' is not declared configurable'));\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(getErrorMsg('Property ' + propertyName + ' does not have access type ' + accessType));\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(getErrorMsg(propertyName + ' has already been spied upon'));\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = (0, _createSpy.default)(propertyName, descriptor[accessType]);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function () {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function () {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      const spiedDescriptor = { ...descriptor,\n        [accessType]: spiedProperty\n      };\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n      return spiedProperty;\n    };\n\n    this.clearSpies = function () {\n      const spies = currentSpies();\n\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n\n}\n\nexports.default = SpyRegistry;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-jasmine2/build/jasmine/spyRegistry.js"],"names":["Object","defineProperty","exports","value","default","_CallTracker","_interopRequireDefault","require","_SpyStrategy","_createSpy","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","formatErrorMsg","domain","usage","usageDefinition","msg","isSpy","putativeSpy","and","calls","getErrorMsg","SpyRegistry","constructor","currentSpies","allowRespy","allow","respy","spyOn","methodName","accessType","_spyOnProperty","Error","descriptor","getOwnPropertyDescriptor","set","originalMethod","spiedMethod","restoreStrategy","prototype","hasOwnProperty","call","push","restoreObjectToOriginalState","propertyName","originalDescriptor","spiedProperty","spiedDescriptor","clearSpies","spies","i","length","spyEntry"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,YAAY,GAAGC,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAzC;;AAEA,IAAIC,YAAY,GAAGF,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAzC;;AAEA,IAAIE,UAAU,GAAGH,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,SAASD,sBAAT,CAAgCI,GAAhC,EAAqC;AACnC,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAACN,IAAAA,OAAO,EAAEM;AAAV,GAArC;AACD;;AAED,SAASE,eAAT,CAAyBF,GAAzB,EAA8BG,GAA9B,EAAmCV,KAAnC,EAA0C;AACxC,MAAIU,GAAG,IAAIH,GAAX,EAAgB;AACdV,IAAAA,MAAM,CAACC,cAAP,CAAsBS,GAAtB,EAA2BG,GAA3B,EAAgC;AAC9BV,MAAAA,KAAK,EAAEA,KADuB;AAE9BW,MAAAA,UAAU,EAAE,IAFkB;AAG9BC,MAAAA,YAAY,EAAE,IAHgB;AAI9BC,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACLN,IAAAA,GAAG,CAACG,GAAD,CAAH,GAAWV,KAAX;AACD;;AACD,SAAOO,GAAP;AACD;;AAED,MAAMO,cAAc,GAAG,CAACC,MAAD,EAASC,KAAT,KAAmB;AACxC,QAAMC,eAAe,GAAGD,KAAK,GAAG,cAAcA,KAAjB,GAAyB,EAAtD;AACA,SAAOE,GAAG,IAAIH,MAAM,GAAG,KAAT,GAAiBG,GAAjB,GAAuBD,eAArC;AACD,CAHD;;AAKA,SAASE,KAAT,CAAeC,WAAf,EAA4B;AAC1B,MAAI,CAACA,WAAL,EAAkB;AAChB,WAAO,KAAP;AACD;;AAED,SACEA,WAAW,CAACC,GAAZ,YAA2BhB,YAAY,CAACJ,OAAxC,IACAmB,WAAW,CAACE,KAAZ,YAA6BpB,YAAY,CAACD,OAF5C;AAID;;AAED,MAAMsB,WAAW,GAAGT,cAAc,CAAC,SAAD,EAAY,+BAAZ,CAAlC;;AAEA,MAAMU,WAAN,CAAkB;AAChBC,EAAAA,WAAW,CAAC;AAACC,IAAAA,YAAY,GAAG,MAAM;AAAtB,MAA4B,EAA7B,EAAiC;AAC1CjB,IAAAA,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,KAAK,CAA1B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAArB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,KAAK,CAA1B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAArB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,gBAAP,EAAyB,KAAK,CAA9B,CAAf;;AAEA,SAAKkB,UAAL,GAAkB,UAAUC,KAAV,EAAiB;AACjC,WAAKC,KAAL,GAAaD,KAAb;AACD,KAFD;;AAIA,SAAKE,KAAL,GAAa,CAACvB,GAAD,EAAMwB,UAAN,EAAkBC,UAAlB,KAAiC;AAC5C,UAAIA,UAAJ,EAAgB;AACd,eAAO,KAAKC,cAAL,CAAoB1B,GAApB,EAAyBwB,UAAzB,EAAqCC,UAArC,CAAP;AACD;;AAED,UAAIzB,GAAG,KAAK,KAAK,CAAjB,EAAoB;AAClB,cAAM,IAAI2B,KAAJ,CACJX,WAAW,CACT,8CAA8CQ,UAA9C,GAA2D,IADlD,CADP,CAAN;AAKD;;AAED,UAAIA,UAAU,KAAK,KAAK,CAAxB,EAA2B;AACzB,cAAM,IAAIG,KAAJ,CAAUX,WAAW,CAAC,yBAAD,CAArB,CAAN;AACD;;AAED,UAAIhB,GAAG,CAACwB,UAAD,CAAH,KAAoB,KAAK,CAA7B,EAAgC;AAC9B,cAAM,IAAIG,KAAJ,CAAUX,WAAW,CAACQ,UAAU,GAAG,0BAAd,CAArB,CAAN;AACD;;AAED,UAAIxB,GAAG,CAACwB,UAAD,CAAH,IAAmBZ,KAAK,CAACZ,GAAG,CAACwB,UAAD,CAAJ,CAA5B,EAA+C;AAC7C,YAAI,KAAKF,KAAT,EAAgB;AACd,iBAAOtB,GAAG,CAACwB,UAAD,CAAV;AACD,SAFD,MAEO;AACL,gBAAM,IAAIG,KAAJ,CACJX,WAAW,CAACQ,UAAU,GAAG,8BAAd,CADP,CAAN;AAGD;AACF;;AAED,UAAII,UAAJ;;AAEA,UAAI;AACFA,QAAAA,UAAU,GAAGtC,MAAM,CAACuC,wBAAP,CAAgC7B,GAAhC,EAAqCwB,UAArC,CAAb;AACD,OAFD,CAEE,MAAM,CACN;AACD;;AAED,UAAII,UAAU,IAAI,EAAEA,UAAU,CAACtB,QAAX,IAAuBsB,UAAU,CAACE,GAApC,CAAlB,EAA4D;AAC1D,cAAM,IAAIH,KAAJ,CACJX,WAAW,CAACQ,UAAU,GAAG,4CAAd,CADP,CAAN;AAGD;;AAED,YAAMO,cAAc,GAAG/B,GAAG,CAACwB,UAAD,CAA1B;AACA,YAAMQ,WAAW,GAAG,CAAC,GAAGjC,UAAU,CAACL,OAAf,EAAwB8B,UAAxB,EAAoCO,cAApC,CAApB;AACA,UAAIE,eAAJ;;AAEA,UAAI3C,MAAM,CAAC4C,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCpC,GAArC,EAA0CwB,UAA1C,CAAJ,EAA2D;AACzDS,QAAAA,eAAe,GAAG,YAAY;AAC5BjC,UAAAA,GAAG,CAACwB,UAAD,CAAH,GAAkBO,cAAlB;AACD,SAFD;AAGD,OAJD,MAIO;AACLE,QAAAA,eAAe,GAAG,YAAY;AAC5B,cAAI,CAAC,OAAOjC,GAAG,CAACwB,UAAD,CAAf,EAA6B;AAC3BxB,YAAAA,GAAG,CAACwB,UAAD,CAAH,GAAkBO,cAAlB;AACD;AACF,SAJD;AAKD;;AAEDZ,MAAAA,YAAY,GAAGkB,IAAf,CAAoB;AAClBC,QAAAA,4BAA4B,EAAEL;AADZ,OAApB;AAGAjC,MAAAA,GAAG,CAACwB,UAAD,CAAH,GAAkBQ,WAAlB;AACA,aAAOA,WAAP;AACD,KAlED;;AAoEA,SAAKN,cAAL,GAAsB,UAAU1B,GAAV,EAAeuC,YAAf,EAA6Bd,UAAU,GAAG,KAA1C,EAAiD;AACrE,UAAI,CAACzB,GAAL,EAAU;AACR,cAAM,IAAI2B,KAAJ,CACJX,WAAW,CACT,8CAA8CuB,YADrC,CADP,CAAN;AAKD;;AAED,UAAI,CAACA,YAAL,EAAmB;AACjB,cAAM,IAAIZ,KAAJ,CAAUX,WAAW,CAAC,2BAAD,CAArB,CAAN;AACD;;AAED,UAAIY,UAAJ;;AAEA,UAAI;AACFA,QAAAA,UAAU,GAAGtC,MAAM,CAACuC,wBAAP,CAAgC7B,GAAhC,EAAqCuC,YAArC,CAAb;AACD,OAFD,CAEE,MAAM,CACN;AACD;;AAED,UAAI,CAACX,UAAL,EAAiB;AACf,cAAM,IAAID,KAAJ,CAAUX,WAAW,CAACuB,YAAY,GAAG,0BAAhB,CAArB,CAAN;AACD;;AAED,UAAI,CAACX,UAAU,CAACvB,YAAhB,EAA8B;AAC5B,cAAM,IAAIsB,KAAJ,CACJX,WAAW,CAACuB,YAAY,GAAG,+BAAhB,CADP,CAAN;AAGD;;AAED,UAAI,CAACX,UAAU,CAACH,UAAD,CAAf,EAA6B;AAC3B,cAAM,IAAIE,KAAJ,CACJX,WAAW,CACT,cACEuB,YADF,GAEE,6BAFF,GAGEd,UAJO,CADP,CAAN;AAQD;;AAED,UAAIzB,GAAG,CAACuC,YAAD,CAAH,IAAqB3B,KAAK,CAACZ,GAAG,CAACuC,YAAD,CAAJ,CAA9B,EAAmD;AACjD,YAAI,KAAKjB,KAAT,EAAgB;AACd,iBAAOtB,GAAG,CAACuC,YAAD,CAAV;AACD,SAFD,MAEO;AACL,gBAAM,IAAIZ,KAAJ,CACJX,WAAW,CAACuB,YAAY,GAAG,8BAAhB,CADP,CAAN;AAGD;AACF;;AAED,YAAMC,kBAAkB,GAAGZ,UAA3B;AACA,YAAMa,aAAa,GAAG,CAAC,GAAG1C,UAAU,CAACL,OAAf,EACpB6C,YADoB,EAEpBX,UAAU,CAACH,UAAD,CAFU,CAAtB;AAIA,UAAIQ,eAAJ;;AAEA,UAAI3C,MAAM,CAAC4C,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCpC,GAArC,EAA0CuC,YAA1C,CAAJ,EAA6D;AAC3DN,QAAAA,eAAe,GAAG,YAAY;AAC5B3C,UAAAA,MAAM,CAACC,cAAP,CAAsBS,GAAtB,EAA2BuC,YAA3B,EAAyCC,kBAAzC;AACD,SAFD;AAGD,OAJD,MAIO;AACLP,QAAAA,eAAe,GAAG,YAAY;AAC5B,iBAAOjC,GAAG,CAACuC,YAAD,CAAV;AACD,SAFD;AAGD;;AAEDpB,MAAAA,YAAY,GAAGkB,IAAf,CAAoB;AAClBC,QAAAA,4BAA4B,EAAEL;AADZ,OAApB;AAGA,YAAMS,eAAe,GAAG,EAAC,GAAGd,UAAJ;AAAgB,SAACH,UAAD,GAAcgB;AAA9B,OAAxB;AACAnD,MAAAA,MAAM,CAACC,cAAP,CAAsBS,GAAtB,EAA2BuC,YAA3B,EAAyCG,eAAzC;AACA,aAAOD,aAAP;AACD,KA3ED;;AA6EA,SAAKE,UAAL,GAAkB,YAAY;AAC5B,YAAMC,KAAK,GAAGzB,YAAY,EAA1B;;AAEA,WAAK,IAAI0B,CAAC,GAAGD,KAAK,CAACE,MAAN,GAAe,CAA5B,EAA+BD,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AAC1C,cAAME,QAAQ,GAAGH,KAAK,CAACC,CAAD,CAAtB;AACAE,QAAAA,QAAQ,CAACT,4BAAT;AACD;AACF,KAPD;AAQD;;AAzKe;;AA4KlB9C,OAAO,CAACE,OAAR,GAAkBuB,WAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _CallTracker = _interopRequireDefault(require('./CallTracker'));\n\nvar _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));\n\nvar _createSpy = _interopRequireDefault(require('./createSpy'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst formatErrorMsg = (domain, usage) => {\n  const usageDefinition = usage ? '\\nUsage: ' + usage : '';\n  return msg => domain + ' : ' + msg + usageDefinition;\n};\n\nfunction isSpy(putativeSpy) {\n  if (!putativeSpy) {\n    return false;\n  }\n\n  return (\n    putativeSpy.and instanceof _SpyStrategy.default &&\n    putativeSpy.calls instanceof _CallTracker.default\n  );\n}\n\nconst getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\n\nclass SpyRegistry {\n  constructor({currentSpies = () => []} = {}) {\n    _defineProperty(this, 'allowRespy', void 0);\n\n    _defineProperty(this, 'spyOn', void 0);\n\n    _defineProperty(this, 'clearSpies', void 0);\n\n    _defineProperty(this, 'respy', void 0);\n\n    _defineProperty(this, '_spyOnProperty', void 0);\n\n    this.allowRespy = function (allow) {\n      this.respy = allow;\n    };\n\n    this.spyOn = (obj, methodName, accessType) => {\n      if (accessType) {\n        return this._spyOnProperty(obj, methodName, accessType);\n      }\n\n      if (obj === void 0) {\n        throw new Error(\n          getErrorMsg(\n            'could not find an object to spy upon for ' + methodName + '()'\n          )\n        );\n      }\n\n      if (methodName === void 0) {\n        throw new Error(getErrorMsg('No method name supplied'));\n      }\n\n      if (obj[methodName] === void 0) {\n        throw new Error(getErrorMsg(methodName + '() method does not exist'));\n      }\n\n      if (obj[methodName] && isSpy(obj[methodName])) {\n        if (this.respy) {\n          return obj[methodName];\n        } else {\n          throw new Error(\n            getErrorMsg(methodName + ' has already been spied upon')\n          );\n        }\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\n      } catch {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (descriptor && !(descriptor.writable || descriptor.set)) {\n        throw new Error(\n          getErrorMsg(methodName + ' is not declared writable or has no setter')\n        );\n      }\n\n      const originalMethod = obj[methodName];\n      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\n        restoreStrategy = function () {\n          obj[methodName] = originalMethod;\n        };\n      } else {\n        restoreStrategy = function () {\n          if (!delete obj[methodName]) {\n            obj[methodName] = originalMethod;\n          }\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      obj[methodName] = spiedMethod;\n      return spiedMethod;\n    };\n\n    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {\n      if (!obj) {\n        throw new Error(\n          getErrorMsg(\n            'could not find an object to spy upon for ' + propertyName\n          )\n        );\n      }\n\n      if (!propertyName) {\n        throw new Error(getErrorMsg('No property name supplied'));\n      }\n\n      let descriptor;\n\n      try {\n        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n      } catch {\n        // IE 8 doesn't support `definePropery` on non-DOM nodes\n      }\n\n      if (!descriptor) {\n        throw new Error(getErrorMsg(propertyName + ' property does not exist'));\n      }\n\n      if (!descriptor.configurable) {\n        throw new Error(\n          getErrorMsg(propertyName + ' is not declared configurable')\n        );\n      }\n\n      if (!descriptor[accessType]) {\n        throw new Error(\n          getErrorMsg(\n            'Property ' +\n              propertyName +\n              ' does not have access type ' +\n              accessType\n          )\n        );\n      }\n\n      if (obj[propertyName] && isSpy(obj[propertyName])) {\n        if (this.respy) {\n          return obj[propertyName];\n        } else {\n          throw new Error(\n            getErrorMsg(propertyName + ' has already been spied upon')\n          );\n        }\n      }\n\n      const originalDescriptor = descriptor;\n      const spiedProperty = (0, _createSpy.default)(\n        propertyName,\n        descriptor[accessType]\n      );\n      let restoreStrategy;\n\n      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {\n        restoreStrategy = function () {\n          Object.defineProperty(obj, propertyName, originalDescriptor);\n        };\n      } else {\n        restoreStrategy = function () {\n          delete obj[propertyName];\n        };\n      }\n\n      currentSpies().push({\n        restoreObjectToOriginalState: restoreStrategy\n      });\n      const spiedDescriptor = {...descriptor, [accessType]: spiedProperty};\n      Object.defineProperty(obj, propertyName, spiedDescriptor);\n      return spiedProperty;\n    };\n\n    this.clearSpies = function () {\n      const spies = currentSpies();\n\n      for (let i = spies.length - 1; i >= 0; i--) {\n        const spyEntry = spies[i];\n        spyEntry.restoreObjectToOriginalState();\n      }\n    };\n  }\n}\n\nexports.default = SpyRegistry;\n"]},"metadata":{},"sourceType":"script"}