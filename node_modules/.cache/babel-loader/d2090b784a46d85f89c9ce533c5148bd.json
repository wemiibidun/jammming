{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nvar _readCoverage = _interopRequireDefault(require(\"./read-coverage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\n\n\nclass Instrumenter {\n  constructor(opts = {}) {\n    this.opts = { ..._schema.defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[({\n        types\n      }) => {\n        const ee = (0, _visitor.default)(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n\n              exit(path) {\n                output = ee.exit(path);\n              }\n\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = (0, _core.transformSync)(code, babelOpts);\n\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = (0, _readCoverage.default)(codeMap.ast) ||\n      /* istanbul ignore next: paranoid check */\n      {};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/istanbul-lib-instrument/dist/instrumenter.js"],"names":["Object","defineProperty","exports","value","default","_core","require","_schema","_visitor","_interopRequireDefault","_readCoverage","obj","__esModule","Instrumenter","constructor","opts","defaults","instrumenter","fileCoverage","sourceMap","instrumentSync","code","filename","inputSourceMap","Error","String","Date","getTime","output","babelOpts","configFile","babelrc","ast","sourceMaps","produceSourceMap","compact","comments","preserveComments","parserOpts","allowReturnOutsideFunction","autoWrap","sourceType","esModules","plugins","parserPlugins","types","ee","coverageVariable","coverageGlobalScope","coverageGlobalScopeFunc","ignoreClassMethods","visitor","Program","enter","exit","path","codeMap","transformSync","initialCoverage","coverageData","map","cb","sourceMapUrlCallback","sourceMappingURL","instrument","callback","out","ex","lastFileCoverage","lastSourceMap","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nvar _readCoverage = _interopRequireDefault(require(\"./read-coverage\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\nclass Instrumenter {\n  constructor(opts = {}) {\n    this.opts = { ..._schema.defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[({\n        types\n      }) => {\n        const ee = (0, _visitor.default)(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n\n              exit(path) {\n                output = ee.exit(path);\n              }\n\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = (0, _core.transformSync)(code, babelOpts);\n\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = (0, _readCoverage.default)(codeMap.ast) ||\n      /* istanbul ignore next: paranoid check */\n      {};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}