{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _types = require('@babel/types');\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestWriteFile = global[Symbol.for('jest-native-write-file')] || fs.writeFileSync;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n\nfunction saveInlineSnapshots(snapshots, prettier, babelTraverse) {\n  if (!prettier) {\n    throw new Error(`Jest: Inline Snapshots requires Prettier.\\n` + `Please ensure \"prettier\" is installed in your project.`);\n  } // Custom parser API was added in 1.5.0\n\n\n  if (_semver.default.lt(prettier.version, '1.5.0')) {\n    throw new Error(`Jest: Inline Snapshots require prettier>=1.5.0.\\n` + `Please upgrade \"prettier\".`);\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier, babelTraverse);\n  }\n}\n\nconst saveSnapshotsForFile = (snapshots, sourceFilePath, prettier, babelTraverse) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n\n  const config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {\n    editorconfig: true\n  }) : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error\n\n  const inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && config.parser || simpleDetectParser(sourceFilePath); // Record the matcher names seen in insertion parser and pass them down one\n  // by one to formatting parser.\n\n  const snapshotMatcherNames = []; // Insert snapshots using the custom parser API. After insertion, the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation).\n\n  const newSourceFile = prettier.format(sourceFile, { ...config,\n    filepath: sourceFilePath,\n    parser: createInsertionParser(snapshots, snapshotMatcherNames, inferredParser, babelTraverse)\n  }); // Format the snapshots using the custom parser API.\n\n  const formattedNewSourceFile = prettier.format(newSourceFile, { ...config,\n    filepath: sourceFilePath,\n    parser: createFormattingParser(snapshotMatcherNames, inferredParser, babelTraverse)\n  });\n\n  if (formattedNewSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, formattedNewSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots => snapshots.reduce((object, inlineSnapshot) => {\n  const key = createKey(inlineSnapshot);\n  return { ...object,\n    [key]: (object[key] || []).concat(inlineSnapshot)\n  };\n}, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({\n  frame: {\n    line,\n    column\n  }\n}) => typeof line === 'number' && typeof column === 'number' ? `${line}:${column - 1}` : '');\nconst groupSnapshotsByFile = groupSnapshotsBy(({\n  frame: {\n    file\n  }\n}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-indentation of inline snapshots.\n\n  if (lines.length >= 2 && lines[1].startsWith(indentation.repeat(numIndents + 1))) {\n    return snapshot;\n  }\n\n  return lines.map((line, index) => {\n    if (index === 0) {\n      // First line is either a 1-line snapshot or a blank line.\n      return line;\n    } else if (index !== lines.length - 1) {\n      // Do not indent empty lines.\n      if (line === '') {\n        return line;\n      } // Not last line, indent one level deeper than expect call.\n\n\n      return indentation.repeat(numIndents + 1) + line;\n    } else {\n      // The last line should be placed on the same level as the expect call.\n      return indentation.repeat(numIndents) + line;\n    }\n  }).join('\\n');\n};\n\nconst getAst = (parsers, inferredParser, text) => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = parsers[inferredParser](text);\n\n  if (ast.type !== 'File') {\n    ast = (0, _types.file)(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n}; // This parser inserts snapshots into the AST.\n\n\nconst createInsertionParser = (snapshots, snapshotMatcherNames, inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({\n    snapshot\n  }) => snapshot));\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || callee.property.loc == null) {\n        return;\n      }\n\n      const {\n        line,\n        column\n      } = callee.property.loc.start;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');\n      }\n\n      snapshotMatcherNames.push(callee.property.name);\n      const snapshotIndex = args.findIndex(({\n        type\n      }) => type === 'TemplateLiteral');\n      const values = snapshotsForFrame.map(({\n        snapshot\n      }) => {\n        remainingSnapshots.delete(snapshot);\n        return (0, _types.templateLiteral)([(0, _types.templateElement)({\n          raw: (0, _utils.escapeBacktickString)(snapshot)\n        })], []);\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(`Jest: Couldn't locate all inline snapshots.`);\n  }\n\n  return ast;\n}; // This parser formats snapshots to the correct indentation.\n\n\nconst createFormattingParser = (snapshotMatcherNames, inferredParser, babelTraverse) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({\n      node: {\n        arguments: args,\n        callee\n      }\n    }) {\n      var _options$tabWidth, _options$tabWidth2;\n\n      if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || !snapshotMatcherNames.includes(callee.property.name) || !callee.loc || callee.computed) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const useSpaces = !options.useTabs;\n      snapshot = indent(snapshot, Math.ceil(useSpaces ? callee.loc.start.column / ((_options$tabWidth = options.tabWidth) !== null && _options$tabWidth !== void 0 ? _options$tabWidth : 1) : callee.loc.start.column / 2 // Each tab is 2 characters.\n      ), useSpaces ? ' '.repeat((_options$tabWidth2 = options.tabWidth) !== null && _options$tabWidth2 !== void 0 ? _options$tabWidth2 : 1) : '\\t');\n      const replacementNode = (0, _types.templateLiteral)([(0, _types.templateElement)({\n        raw: snapshot\n      })], []);\n      args[snapshotIndex] = replacementNode;\n    }\n\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = path.extname(filePath);\n\n  if (/tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babel';\n};","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-snapshot/build/InlineSnapshots.js"],"names":["Object","defineProperty","exports","value","saveInlineSnapshots","path","_interopRequireWildcard","require","_types","fs","_semver","_interopRequireDefault","_utils","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","global","jestWriteFile","for","writeFileSync","jestReadFile","readFileSync","snapshots","prettier","babelTraverse","Error","lt","version","snapshotsByFile","groupSnapshotsByFile","sourceFilePath","keys","saveSnapshotsForFile","sourceFile","config","resolveConfig","sync","editorconfig","inferredParser","getFileInfo","parser","simpleDetectParser","snapshotMatcherNames","newSourceFile","format","filepath","createInsertionParser","formattedNewSourceFile","createFormattingParser","groupSnapshotsBy","createKey","reduce","object","inlineSnapshot","concat","groupSnapshotsByFrame","frame","line","column","file","indent","snapshot","numIndents","indentation","lines","split","length","startsWith","repeat","map","index","join","getAst","parsers","text","ast","type","comments","tokens","program","options","groupedSnapshots","remainingSnapshots","Set","CallExpression","node","arguments","args","callee","property","loc","start","snapshotsForFrame","push","name","snapshotIndex","findIndex","values","delete","templateLiteral","templateElement","raw","escapeBacktickString","replacementNode","size","_options$tabWidth","_options$tabWidth2","includes","computed","i","quasis","undefined","useSpaces","useTabs","Math","ceil","tabWidth","filePath","extname","test"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.saveInlineSnapshots = saveInlineSnapshots;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _types = require('@babel/types');\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _semver = _interopRequireDefault(require('semver'));\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestWriteFile =\n  global[Symbol.for('jest-native-write-file')] || fs.writeFileSync;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestReadFile =\n  global[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n\nfunction saveInlineSnapshots(snapshots, prettier, babelTraverse) {\n  if (!prettier) {\n    throw new Error(\n      `Jest: Inline Snapshots requires Prettier.\\n` +\n        `Please ensure \"prettier\" is installed in your project.`\n    );\n  } // Custom parser API was added in 1.5.0\n\n  if (_semver.default.lt(prettier.version, '1.5.0')) {\n    throw new Error(\n      `Jest: Inline Snapshots require prettier>=1.5.0.\\n` +\n        `Please upgrade \"prettier\".`\n    );\n  }\n\n  const snapshotsByFile = groupSnapshotsByFile(snapshots);\n\n  for (const sourceFilePath of Object.keys(snapshotsByFile)) {\n    saveSnapshotsForFile(\n      snapshotsByFile[sourceFilePath],\n      sourceFilePath,\n      prettier,\n      babelTraverse\n    );\n  }\n}\n\nconst saveSnapshotsForFile = (\n  snapshots,\n  sourceFilePath,\n  prettier,\n  babelTraverse\n) => {\n  const sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.\n  // For older versions of Prettier, do not load configuration.\n\n  const config = prettier.resolveConfig\n    ? prettier.resolveConfig.sync(sourceFilePath, {\n        editorconfig: true\n      })\n    : null; // Detect the parser for the test file.\n  // For older versions of Prettier, fallback to a simple parser detection.\n  // @ts-expect-error\n\n  const inferredParser = prettier.getFileInfo\n    ? prettier.getFileInfo.sync(sourceFilePath).inferredParser\n    : (config && config.parser) || simpleDetectParser(sourceFilePath); // Record the matcher names seen in insertion parser and pass them down one\n  // by one to formatting parser.\n\n  const snapshotMatcherNames = []; // Insert snapshots using the custom parser API. After insertion, the code is\n  // formatted, except snapshot indentation. Snapshots cannot be formatted until\n  // after the initial format because we don't know where the call expression\n  // will be placed (specifically its indentation).\n\n  const newSourceFile = prettier.format(sourceFile, {\n    ...config,\n    filepath: sourceFilePath,\n    parser: createInsertionParser(\n      snapshots,\n      snapshotMatcherNames,\n      inferredParser,\n      babelTraverse\n    )\n  }); // Format the snapshots using the custom parser API.\n\n  const formattedNewSourceFile = prettier.format(newSourceFile, {\n    ...config,\n    filepath: sourceFilePath,\n    parser: createFormattingParser(\n      snapshotMatcherNames,\n      inferredParser,\n      babelTraverse\n    )\n  });\n\n  if (formattedNewSourceFile !== sourceFile) {\n    jestWriteFile(sourceFilePath, formattedNewSourceFile);\n  }\n};\n\nconst groupSnapshotsBy = createKey => snapshots =>\n  snapshots.reduce((object, inlineSnapshot) => {\n    const key = createKey(inlineSnapshot);\n    return {...object, [key]: (object[key] || []).concat(inlineSnapshot)};\n  }, {});\n\nconst groupSnapshotsByFrame = groupSnapshotsBy(({frame: {line, column}}) =>\n  typeof line === 'number' && typeof column === 'number'\n    ? `${line}:${column - 1}`\n    : ''\n);\nconst groupSnapshotsByFile = groupSnapshotsBy(({frame: {file}}) => file);\n\nconst indent = (snapshot, numIndents, indentation) => {\n  const lines = snapshot.split('\\n'); // Prevent re-indentation of inline snapshots.\n\n  if (\n    lines.length >= 2 &&\n    lines[1].startsWith(indentation.repeat(numIndents + 1))\n  ) {\n    return snapshot;\n  }\n\n  return lines\n    .map((line, index) => {\n      if (index === 0) {\n        // First line is either a 1-line snapshot or a blank line.\n        return line;\n      } else if (index !== lines.length - 1) {\n        // Do not indent empty lines.\n        if (line === '') {\n          return line;\n        } // Not last line, indent one level deeper than expect call.\n\n        return indentation.repeat(numIndents + 1) + line;\n      } else {\n        // The last line should be placed on the same level as the expect call.\n        return indentation.repeat(numIndents) + line;\n      }\n    })\n    .join('\\n');\n};\n\nconst getAst = (parsers, inferredParser, text) => {\n  // Flow uses a 'Program' parent node, babel expects a 'File'.\n  let ast = parsers[inferredParser](text);\n\n  if (ast.type !== 'File') {\n    ast = (0, _types.file)(ast, ast.comments, ast.tokens);\n    delete ast.program.comments;\n  }\n\n  return ast;\n}; // This parser inserts snapshots into the AST.\n\nconst createInsertionParser = (\n  snapshots,\n  snapshotMatcherNames,\n  inferredParser,\n  babelTraverse\n) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const groupedSnapshots = groupSnapshotsByFrame(snapshots);\n  const remainingSnapshots = new Set(snapshots.map(({snapshot}) => snapshot));\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({node: {arguments: args, callee}}) {\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier' ||\n        callee.property.loc == null\n      ) {\n        return;\n      }\n\n      const {line, column} = callee.property.loc.start;\n      const snapshotsForFrame = groupedSnapshots[`${line}:${column}`];\n\n      if (!snapshotsForFrame) {\n        return;\n      }\n\n      if (snapshotsForFrame.length > 1) {\n        throw new Error(\n          'Jest: Multiple inline snapshots for the same call are not supported.'\n        );\n      }\n\n      snapshotMatcherNames.push(callee.property.name);\n      const snapshotIndex = args.findIndex(\n        ({type}) => type === 'TemplateLiteral'\n      );\n      const values = snapshotsForFrame.map(({snapshot}) => {\n        remainingSnapshots.delete(snapshot);\n        return (0, _types.templateLiteral)(\n          [\n            (0, _types.templateElement)({\n              raw: (0, _utils.escapeBacktickString)(snapshot)\n            })\n          ],\n          []\n        );\n      });\n      const replacementNode = values[0];\n\n      if (snapshotIndex > -1) {\n        args[snapshotIndex] = replacementNode;\n      } else {\n        args.push(replacementNode);\n      }\n    }\n  });\n\n  if (remainingSnapshots.size) {\n    throw new Error(`Jest: Couldn't locate all inline snapshots.`);\n  }\n\n  return ast;\n}; // This parser formats snapshots to the correct indentation.\n\nconst createFormattingParser = (\n  snapshotMatcherNames,\n  inferredParser,\n  babelTraverse\n) => (text, parsers, options) => {\n  // Workaround for https://github.com/prettier/prettier/issues/3150\n  options.parser = inferredParser;\n  const ast = getAst(parsers, inferredParser, text);\n  babelTraverse(ast, {\n    CallExpression({node: {arguments: args, callee}}) {\n      var _options$tabWidth, _options$tabWidth2;\n\n      if (\n        callee.type !== 'MemberExpression' ||\n        callee.property.type !== 'Identifier' ||\n        !snapshotMatcherNames.includes(callee.property.name) ||\n        !callee.loc ||\n        callee.computed\n      ) {\n        return;\n      }\n\n      let snapshotIndex;\n      let snapshot;\n\n      for (let i = 0; i < args.length; i++) {\n        const node = args[i];\n\n        if (node.type === 'TemplateLiteral') {\n          snapshotIndex = i;\n          snapshot = node.quasis[0].value.raw;\n        }\n      }\n\n      if (snapshot === undefined || snapshotIndex === undefined) {\n        return;\n      }\n\n      const useSpaces = !options.useTabs;\n      snapshot = indent(\n        snapshot,\n        Math.ceil(\n          useSpaces\n            ? callee.loc.start.column /\n                ((_options$tabWidth = options.tabWidth) !== null &&\n                _options$tabWidth !== void 0\n                  ? _options$tabWidth\n                  : 1)\n            : callee.loc.start.column / 2 // Each tab is 2 characters.\n        ),\n        useSpaces\n          ? ' '.repeat(\n              (_options$tabWidth2 = options.tabWidth) !== null &&\n                _options$tabWidth2 !== void 0\n                ? _options$tabWidth2\n                : 1\n            )\n          : '\\t'\n      );\n      const replacementNode = (0, _types.templateLiteral)(\n        [\n          (0, _types.templateElement)({\n            raw: snapshot\n          })\n        ],\n        []\n      );\n      args[snapshotIndex] = replacementNode;\n    }\n  });\n  return ast;\n};\n\nconst simpleDetectParser = filePath => {\n  const extname = path.extname(filePath);\n\n  if (/tsx?$/.test(extname)) {\n    return 'typescript';\n  }\n\n  return 'babel';\n};\n"]},"metadata":{},"sourceType":"script"}