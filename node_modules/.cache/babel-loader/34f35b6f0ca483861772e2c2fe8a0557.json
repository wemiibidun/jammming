{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.Identifier = Identifier;\n\nvar t = require(\"@babel/types\");\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return t.isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    const isFollowedByBracket = t.isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || t.isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && t.isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, {\n  expressionStatement = false,\n  arrowBody = false,\n  exportDefault = false,\n  forHead = false,\n  forInHead = false,\n  forOfHead = false\n}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && t.isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && t.isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && t.isForStatement(parent, {\n      init: node\n    }) || forInHead && t.isForInStatement(parent, {\n      left: node\n    }) || forOfHead && t.isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","NullableTypeAnnotation","FunctionTypeAnnotation","UpdateExpression","ObjectExpression","DoExpression","Binary","IntersectionTypeAnnotation","UnionTypeAnnotation","OptionalIndexedAccessType","TSAsExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","TSInferType","BinaryExpression","SequenceExpression","AwaitExpression","YieldExpression","ClassExpression","UnaryLike","FunctionExpression","ArrowFunctionExpression","ConditionalExpression","OptionalCallExpression","OptionalMemberExpression","AssignmentExpression","LogicalExpression","Identifier","t","require","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","isClassDeclaration","isClassExpression","superClass","hasPostfixPart","isMemberExpression","isOptionalMemberExpression","object","isCallExpression","isOptionalCallExpression","isNewExpression","callee","isTaggedTemplateExpression","tag","isTSNonNullExpression","isArrayTypeAnnotation","printStack","isUnionTypeAnnotation","isIntersectionTypeAnnotation","isTypeAnnotation","isArrowFunctionExpression","length","isFirstInContext","expressionStatement","arrowBody","async","operator","isBinaryExpression","left","isUnaryLike","isAwaitExpression","isBinary","parentOp","parentPos","nodeOp","nodePos","right","isLogicalExpression","isNullableTypeAnnotation","isIndexedAccessType","objectType","isTSArrayType","isTSOptionalType","isTSIntersectionType","isTSUnionType","isTSRestType","isVariableDeclarator","isFor","isForStatement","isThrowStatement","isReturnStatement","isIfStatement","test","isWhileStatement","isForInStatement","isSwitchStatement","discriminant","isExpressionStatement","expression","isYieldExpression","isConditionalExpression","exportDefault","isExportDeclaration","isTSTypeAssertion","isTSAsExpression","isObjectPattern","name","isFollowedByBracket","computed","optional","forHead","forInHead","forOfHead","isForOfStatement","i","isExportDefaultDeclaration","declaration","body","init","isSequenceExpression","expressions","isConditional","isAssignmentExpression"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.DoExpression = DoExpression;\nexports.Binary = Binary;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.TSInferType = TSInferType;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.Identifier = Identifier;\n\nvar t = require(\"@babel/types\");\n\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (t.isClassDeclaration(parent) || t.isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (t.isMemberExpression(parent) || t.isOptionalMemberExpression(parent)) && parent.object === node || (t.isCallExpression(parent) || t.isOptionalCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node || t.isTaggedTemplateExpression(parent) && parent.tag === node || t.isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return t.isUnionTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isArrayTypeAnnotation(parent) || t.isTypeAnnotation(parent) && t.isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && t.isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || t.isUnaryLike(parent) || t.isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent) || t.isNullableTypeAnnotation(parent) || t.isIntersectionTypeAnnotation(parent) || t.isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return t.isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent) || t.isTSIntersectionType(parent) || t.isTSUnionType(parent) || t.isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return t.isTSArrayType(parent) || t.isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (t.isVariableDeclarator(parent) || t.isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent) || t.isThrowStatement(parent) || t.isReturnStatement(parent) || t.isIfStatement(parent) && parent.test === node || t.isWhileStatement(parent) && parent.test === node || t.isForInStatement(parent) && parent.right === node || t.isSwitchStatement(parent) && parent.discriminant === node || t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || hasPostfixPart(node, parent) || t.isAwaitExpression(parent) && t.isYieldExpression(node) || t.isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || t.isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return t.isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent) || t.isBinary(parent) || t.isConditionalExpression(parent, {\n    test: node\n  }) || t.isAwaitExpression(parent) || t.isTSTypeAssertion(parent) || t.isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return t.isCallExpression(parent, {\n    callee: node\n  }) || t.isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!t.isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return t.isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return t.isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    const isFollowedByBracket = t.isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || t.isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && t.isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, {\n  expressionStatement = false,\n  arrowBody = false,\n  exportDefault = false,\n  forHead = false,\n  forInHead = false,\n  forOfHead = false\n}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && t.isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && t.isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && t.isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && t.isForStatement(parent, {\n      init: node\n    }) || forInHead && t.isForInStatement(parent, {\n      left: node\n    }) || forOfHead && t.isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !t.isNewExpression(parent) || t.isSequenceExpression(parent) && parent.expressions[0] === node || t.isConditional(parent, {\n      test: node\n    }) || t.isBinary(parent, {\n      left: node\n    }) || t.isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}