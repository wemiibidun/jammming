{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.dedentLines = void 0;\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst getIndentationLength = line => {\n  const result = /^( {2})+/.exec(line);\n  return result === null ? 0 : result[0].length;\n};\n\nconst dedentLine = line => line.slice(getIndentationLength(line)); // Return true if:\n// \"key\": \"value has multiple lines\\n…\n// \"key has multiple lines\\n…\n\n\nconst hasUnmatchedDoubleQuoteMarks = string => {\n  let n = 0;\n  let i = string.indexOf('\"', 0);\n\n  while (i !== -1) {\n    if (i === 0 || string[i - 1] !== '\\\\') {\n      n += 1;\n    }\n\n    i = string.indexOf('\"', i + 1);\n  }\n\n  return n % 2 !== 0;\n};\n\nconst isFirstLineOfTag = line => /^( {2})*\\</.test(line); // The length of the output array is the index of the next input line.\n// Push dedented lines of start tag onto output and return true;\n// otherwise return false because:\n// * props include a multiline string (or text node, if props have markup)\n// * start tag does not close\n\n\nconst dedentStartTag = (input, output) => {\n  let line = input[output.length];\n  output.push(dedentLine(line));\n\n  if (line.includes('>')) {\n    return true;\n  }\n\n  while (output.length < input.length) {\n    line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return false; // because props include a multiline string\n    } else if (isFirstLineOfTag(line)) {\n      // Recursion only if props have markup.\n      if (!dedentMarkup(input, output)) {\n        return false;\n      }\n    } else {\n      output.push(dedentLine(line));\n\n      if (line.includes('>')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Push dedented lines of markup onto output and return true;\n// otherwise return false because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\n\nconst dedentMarkup = (input, output) => {\n  let line = input[output.length];\n\n  if (!dedentStartTag(input, output)) {\n    return false;\n  }\n\n  if (input[output.length - 1].includes('/>')) {\n    return true;\n  }\n\n  let isText = false;\n  const stack = [];\n  stack.push(getIndentationLength(line));\n\n  while (stack.length > 0 && output.length < input.length) {\n    line = input[output.length];\n\n    if (isFirstLineOfTag(line)) {\n      if (line.includes('</')) {\n        output.push(dedentLine(line));\n        stack.pop();\n      } else {\n        if (!dedentStartTag(input, output)) {\n          return false;\n        }\n\n        if (!input[output.length - 1].includes('/>')) {\n          stack.push(getIndentationLength(line));\n        }\n      }\n\n      isText = false;\n    } else {\n      if (isText) {\n        return false; // because text has more than one adjacent line\n      }\n\n      const indentationLengthOfTag = stack[stack.length - 1];\n      output.push(line.slice(indentationLengthOfTag + 2));\n      isText = true;\n    }\n  }\n\n  return stack.length === 0;\n}; // Return lines unindented by heuristic;\n// otherwise return null because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\n\nconst dedentLines = input => {\n  const output = [];\n\n  while (output.length < input.length) {\n    const line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return null;\n    } else if (isFirstLineOfTag(line)) {\n      if (!dedentMarkup(input, output)) {\n        return null;\n      }\n    } else {\n      output.push(dedentLine(line));\n    }\n  }\n\n  return output;\n};\n\nexports.dedentLines = dedentLines;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-snapshot/build/dedentLines.js"],"names":["Object","defineProperty","exports","value","dedentLines","getIndentationLength","line","result","exec","length","dedentLine","slice","hasUnmatchedDoubleQuoteMarks","string","n","i","indexOf","isFirstLineOfTag","test","dedentStartTag","input","output","push","includes","dedentMarkup","isText","stack","pop","indentationLengthOfTag"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.dedentLines = void 0;\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst getIndentationLength = line => {\n  const result = /^( {2})+/.exec(line);\n  return result === null ? 0 : result[0].length;\n};\n\nconst dedentLine = line => line.slice(getIndentationLength(line)); // Return true if:\n// \"key\": \"value has multiple lines\\n…\n// \"key has multiple lines\\n…\n\nconst hasUnmatchedDoubleQuoteMarks = string => {\n  let n = 0;\n  let i = string.indexOf('\"', 0);\n\n  while (i !== -1) {\n    if (i === 0 || string[i - 1] !== '\\\\') {\n      n += 1;\n    }\n\n    i = string.indexOf('\"', i + 1);\n  }\n\n  return n % 2 !== 0;\n};\n\nconst isFirstLineOfTag = line => /^( {2})*\\</.test(line); // The length of the output array is the index of the next input line.\n// Push dedented lines of start tag onto output and return true;\n// otherwise return false because:\n// * props include a multiline string (or text node, if props have markup)\n// * start tag does not close\n\nconst dedentStartTag = (input, output) => {\n  let line = input[output.length];\n  output.push(dedentLine(line));\n\n  if (line.includes('>')) {\n    return true;\n  }\n\n  while (output.length < input.length) {\n    line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return false; // because props include a multiline string\n    } else if (isFirstLineOfTag(line)) {\n      // Recursion only if props have markup.\n      if (!dedentMarkup(input, output)) {\n        return false;\n      }\n    } else {\n      output.push(dedentLine(line));\n\n      if (line.includes('>')) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // Push dedented lines of markup onto output and return true;\n// otherwise return false because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\nconst dedentMarkup = (input, output) => {\n  let line = input[output.length];\n\n  if (!dedentStartTag(input, output)) {\n    return false;\n  }\n\n  if (input[output.length - 1].includes('/>')) {\n    return true;\n  }\n\n  let isText = false;\n  const stack = [];\n  stack.push(getIndentationLength(line));\n\n  while (stack.length > 0 && output.length < input.length) {\n    line = input[output.length];\n\n    if (isFirstLineOfTag(line)) {\n      if (line.includes('</')) {\n        output.push(dedentLine(line));\n        stack.pop();\n      } else {\n        if (!dedentStartTag(input, output)) {\n          return false;\n        }\n\n        if (!input[output.length - 1].includes('/>')) {\n          stack.push(getIndentationLength(line));\n        }\n      }\n\n      isText = false;\n    } else {\n      if (isText) {\n        return false; // because text has more than one adjacent line\n      }\n\n      const indentationLengthOfTag = stack[stack.length - 1];\n      output.push(line.slice(indentationLengthOfTag + 2));\n      isText = true;\n    }\n  }\n\n  return stack.length === 0;\n}; // Return lines unindented by heuristic;\n// otherwise return null because:\n// * props include a multiline string\n// * text has more than one adjacent line\n// * markup does not close\n\nconst dedentLines = input => {\n  const output = [];\n\n  while (output.length < input.length) {\n    const line = input[output.length];\n\n    if (hasUnmatchedDoubleQuoteMarks(line)) {\n      return null;\n    } else if (isFirstLineOfTag(line)) {\n      if (!dedentMarkup(input, output)) {\n        return null;\n      }\n    } else {\n      output.push(dedentLine(line));\n    }\n  }\n\n  return output;\n};\n\nexports.dedentLines = dedentLines;\n"]},"metadata":{},"sourceType":"script"}