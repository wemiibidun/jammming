{"ast":null,"code":"let globalPnpApi;\n\ntry {\n  globalPnpApi = require(`pnpapi`);\n} catch {// Just ignore if we don't have a global PnP instance - perhaps\n  // we'll eventually find one at runtime due to multi-tree\n}\n\nconst createRequire = require(`./createRequire`);\n\nconst getDefaultResolver = require(`./getDefaultResolver`);\n\nmodule.exports = (request, options) => {\n  const {\n    basedir,\n    defaultResolver,\n    extensions\n  } = options;\n\n  if (process.versions.pnp) {\n    let pnpApi = globalPnpApi; // While technically it would be more correct to run this code\n    // everytime (since they file being run *may* belong to a\n    // different dependency tree than the one owning Jest), in\n    // practice this doesn't happen anywhere else than on the Jest\n    // repository itself (in the test env). So in order to preserve\n    // the performances, we can afford a slight incoherence here.\n\n    if (!pnpApi) {\n      try {\n        const baseReq = createRequire(`${basedir}/internal.js`);\n        pnpApi = baseReq(`pnpapi`);\n      } catch {// The file isn't part of a PnP dependency tree, so we can\n        // just use the default Jest resolver.\n      }\n    }\n\n    if (pnpApi) {\n      const resolution = pnpApi.resolveRequest(request, `${basedir}/`, {\n        extensions\n      }); // When the request is a native module, Jest expects to get the string back unmodified, but pnp returns null instead.\n\n      if (resolution === null) return request;\n      return resolution;\n    }\n  }\n\n  if (!defaultResolver) defaultResolver = getDefaultResolver();\n  return defaultResolver(request, { ...options,\n    allowPnp: false\n  });\n};","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/jest-pnp-resolver/index.js"],"names":["globalPnpApi","require","createRequire","getDefaultResolver","module","exports","request","options","basedir","defaultResolver","extensions","process","versions","pnp","pnpApi","baseReq","resolution","resolveRequest","allowPnp"],"mappings":"AAAA,IAAIA,YAAJ;;AACA,IAAI;AACAA,EAAAA,YAAY,GAAGC,OAAO,CAAE,QAAF,CAAtB;AACH,CAFD,CAEE,MAAM,CACJ;AACA;AACH;;AAED,MAAMC,aAAa,GAAGD,OAAO,CAAE,iBAAF,CAA7B;;AACA,MAAME,kBAAkB,GAAGF,OAAO,CAAE,sBAAF,CAAlC;;AAEAG,MAAM,CAACC,OAAP,GAAiB,CAACC,OAAD,EAAUC,OAAV,KAAsB;AACrC,QAAM;AAACC,IAAAA,OAAD;AAAUC,IAAAA,eAAV;AAA2BC,IAAAA;AAA3B,MAAyCH,OAA/C;;AAEA,MAAII,OAAO,CAACC,QAAR,CAAiBC,GAArB,EAA0B;AACxB,QAAIC,MAAM,GAAGd,YAAb,CADwB,CAGxB;AACA;AACA;AACA;AACA;AACA;;AACA,QAAI,CAACc,MAAL,EAAa;AACX,UAAI;AACF,cAAMC,OAAO,GAAGb,aAAa,CAAE,GAAEM,OAAQ,cAAZ,CAA7B;AACAM,QAAAA,MAAM,GAAGC,OAAO,CAAE,QAAF,CAAhB;AACD,OAHD,CAGE,MAAM,CACN;AACA;AACD;AACF;;AAED,QAAID,MAAJ,EAAY;AACV,YAAME,UAAU,GAAGF,MAAM,CAACG,cAAP,CAAsBX,OAAtB,EAAgC,GAAEE,OAAQ,GAA1C,EAA8C;AAACE,QAAAA;AAAD,OAA9C,CAAnB,CADU,CAGV;;AACA,UAAIM,UAAU,KAAK,IAAnB,EACE,OAAOV,OAAP;AAEF,aAAOU,UAAP;AACD;AACF;;AAED,MAAI,CAACP,eAAL,EACEA,eAAe,GAAGN,kBAAkB,EAApC;AAEF,SAAOM,eAAe,CAACH,OAAD,EAAU,EAAC,GAAGC,OAAJ;AAAaW,IAAAA,QAAQ,EAAE;AAAvB,GAAV,CAAtB;AACD,CArCD","sourcesContent":["let globalPnpApi;\ntry {\n    globalPnpApi = require(`pnpapi`);\n} catch {\n    // Just ignore if we don't have a global PnP instance - perhaps\n    // we'll eventually find one at runtime due to multi-tree\n}\n\nconst createRequire = require(`./createRequire`);\nconst getDefaultResolver = require(`./getDefaultResolver`);\n\nmodule.exports = (request, options) => {\n  const {basedir, defaultResolver, extensions} = options;\n\n  if (process.versions.pnp) {\n    let pnpApi = globalPnpApi;\n\n    // While technically it would be more correct to run this code\n    // everytime (since they file being run *may* belong to a\n    // different dependency tree than the one owning Jest), in\n    // practice this doesn't happen anywhere else than on the Jest\n    // repository itself (in the test env). So in order to preserve\n    // the performances, we can afford a slight incoherence here.\n    if (!pnpApi) {\n      try {\n        const baseReq = createRequire(`${basedir}/internal.js`);\n        pnpApi = baseReq(`pnpapi`);\n      } catch {\n        // The file isn't part of a PnP dependency tree, so we can\n        // just use the default Jest resolver.\n      }\n    }\n\n    if (pnpApi) {\n      const resolution = pnpApi.resolveRequest(request, `${basedir}/`, {extensions});\n\n      // When the request is a native module, Jest expects to get the string back unmodified, but pnp returns null instead.\n      if (resolution === null)\n        return request;\n\n      return resolution;\n    }\n  }\n\n  if (!defaultResolver)\n    defaultResolver = getDefaultResolver();\n\n  return defaultResolver(request, {...options, allowPnp: false});\n};\n"]},"metadata":{},"sourceType":"script"}