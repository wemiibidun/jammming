{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction os() {\n  const data = _interopRequireWildcard(require('os'));\n\n  os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = _interopRequireDefault(require('jest-resolve-dependencies'));\n\n  _jestResolveDependencies = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst regexToMatcher = testRegex => {\n  const regexes = testRegex.map(testRegex => new RegExp(testRegex));\n  return path => regexes.some(regex => {\n    const result = regex.test(path); // prevent stateful regexes from breaking, just in case\n\n    regex.lastIndex = 0;\n    return result;\n  });\n};\n\nconst toTests = (context, tests) => tests.map(path => ({\n  context,\n  duration: undefined,\n  path\n}));\n\nconst hasSCM = changedFilesInfo => {\n  const {\n    repos\n  } = changedFilesInfo; // no SCM (git/hg/...) is found in any of the roots.\n\n  const noSCM = Object.values(repos).every(scm => scm.size === 0);\n  return !noSCM;\n};\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_dependencyResolver', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const {\n      config\n    } = context;\n    this._context = context;\n    this._dependencyResolver = null;\n    const rootPattern = new RegExp(config.roots.map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + path().sep)).join('|'));\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: (0, _jestUtil().globsToMatcher)(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(config.testPathIgnorePatterns.join('|'));\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  _getOrBuildDependencyResolver() {\n    if (!this._dependencyResolver) {\n      this._dependencyResolver = new (_jestResolveDependencies().default)(this._context.resolver, this._context.hasteFS, (0, _jestSnapshot().buildSnapshotResolver)(this._context.config));\n    }\n\n    return this._dependencyResolver;\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (const {\n        isMatch,\n        stat\n      } of testCases) {\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(toTests(this._context, this._context.hasteFS.getAllFiles()), testPathPattern);\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = this._getOrBuildDependencyResolver();\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(this._context, dependencyResolver.resolveInverse(allPaths, this.isTestFilePath.bind(this), {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        }))\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(allPaths, this.isTestFilePath.bind(this), {\n      skipNodeResolution: this._context.config.skipNodeResolution\n    });\n    const allPathsAbsolute = Array.from(allPaths).map(p => path().resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.forEach(p => {\n        if (!allPathsAbsolute.includes(p)) {\n          return;\n        }\n\n        const filename = (0, _jestConfig().replaceRootDirInPath)(this._context.config.rootDir, p);\n        collectCoverageFrom.add(path().isAbsolute(filename) ? path().relative(this._context.config.rootDir, filename) : filename);\n      });\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(this._context, testModulesMap.map(testModule => testModule.file))\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(this._context, paths.map(p => path().resolve(this._context.config.cwd, p)).filter(this.isTestFilePath.bind(this)))\n    };\n  }\n\n  findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p => path().resolve(this._context.config.cwd, p));\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    if (!hasSCM(changedFilesInfo)) {\n      return {\n        noSCM: true,\n        tests: []\n      };\n    }\n\n    const {\n      changedFiles\n    } = changedFilesInfo;\n    return this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  _getTestPaths(globalConfig, changedFiles) {\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage);\n    }\n\n    let paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.findRelatedTests && 'win32' === os().platform()) {\n      const allFiles = this._context.hasteFS.getAllFiles();\n\n      const options = {\n        nocase: true,\n        windows: false\n      };\n      paths = paths.map(p => {\n        const relativePath = path().resolve(this._context.config.cwd, p).replace(/\\\\/g, '\\\\\\\\');\n        const match = (0, _micromatch().default)(allFiles, relativePath, options);\n        return match[0];\n      }).filter(Boolean);\n    }\n\n    if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(paths, globalConfig.collectCoverage);\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  async getTestPaths(globalConfig, changedFiles, filter) {\n    const searchResult = this._getTestPaths(globalConfig, changedFiles);\n\n    const filterPath = globalConfig.filter;\n\n    if (filter) {\n      const tests = searchResult.tests;\n      const filterResult = await filter(tests.map(test => test.path));\n\n      if (!Array.isArray(filterResult.filtered)) {\n        throw new Error(`Filter ${filterPath} did not return a valid test list`);\n      }\n\n      const filteredSet = new Set(filterResult.filtered.map(result => result.test));\n      return { ...searchResult,\n        tests: tests.filter(test => filteredSet.has(test.path))\n      };\n    }\n\n    return searchResult;\n  }\n\n  findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo) {\n    if (!hasSCM(changedFilesInfo)) {\n      return [];\n    }\n\n    const {\n      changedFiles\n    } = changedFilesInfo;\n\n    const dependencyResolver = this._getOrBuildDependencyResolver();\n\n    const relatedSourcesSet = new Set();\n    changedFiles.forEach(filePath => {\n      if (this.isTestFilePath(filePath)) {\n        const sourcePaths = dependencyResolver.resolve(filePath, {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        });\n        sourcePaths.forEach(sourcePath => relatedSourcesSet.add(sourcePath));\n      }\n    });\n    return Array.from(relatedSourcesSet);\n  }\n\n}\n\nexports.default = SearchSource;","map":{"version":3,"sources":["/Users/wemi/jammming/node_modules/@jest/core/build/SearchSource.js"],"names":["Object","defineProperty","exports","value","default","os","data","_interopRequireWildcard","require","path","_micromatch","_interopRequireDefault","_jestConfig","_jestRegexUtil","_jestResolveDependencies","_jestSnapshot","_jestUtil","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","regexToMatcher","testRegex","regexes","map","RegExp","some","regex","result","test","lastIndex","toTests","context","tests","duration","undefined","hasSCM","changedFilesInfo","repos","noSCM","values","every","scm","size","SearchSource","constructor","config","_context","_dependencyResolver","rootPattern","roots","dir","escapePathForRegex","sep","join","_testPathCases","push","isMatch","stat","testMatch","length","globsToMatcher","testPathIgnorePatterns","testIgnorePatternsRegex","_getOrBuildDependencyResolver","resolver","hasteFS","buildSnapshotResolver","_filterTestPathsWithStats","allPaths","testPathPattern","stats","total","testCases","Array","from","testPathPatternToRegExp","filter","filterResult","_getAllTestPaths","getAllFiles","isTestFilePath","testCase","findMatchingTests","findRelatedTests","collectCoverage","dependencyResolver","resolveInverse","bind","skipNodeResolution","testModulesMap","resolveInverseModuleMap","allPathsAbsolute","p","resolve","collectCoverageFrom","Set","forEach","testModule","dependencies","includes","filename","replaceRootDirInPath","rootDir","add","isAbsolute","relative","file","findTestsByPaths","paths","cwd","findRelatedTestsFromPattern","isArray","resolvedPaths","findTestRelatedToChangedFiles","changedFiles","_getTestPaths","globalConfig","onlyChanged","Error","nonFlagArgs","platform","allFiles","options","nocase","windows","relativePath","replace","match","Boolean","runTestsByPath","getTestPaths","searchResult","filterPath","filtered","filteredSet","findRelatedSourcesFromTestsInChangedFiles","relatedSourcesSet","filePath","sourcePaths","sourcePath"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction os() {\n  const data = _interopRequireWildcard(require('os'));\n\n  os = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _micromatch() {\n  const data = _interopRequireDefault(require('micromatch'));\n\n  _micromatch = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestConfig() {\n  const data = require('jest-config');\n\n  _jestConfig = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolveDependencies() {\n  const data = _interopRequireDefault(require('jest-resolve-dependencies'));\n\n  _jestResolveDependencies = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = require('jest-snapshot');\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst regexToMatcher = testRegex => {\n  const regexes = testRegex.map(testRegex => new RegExp(testRegex));\n  return path =>\n    regexes.some(regex => {\n      const result = regex.test(path); // prevent stateful regexes from breaking, just in case\n\n      regex.lastIndex = 0;\n      return result;\n    });\n};\n\nconst toTests = (context, tests) =>\n  tests.map(path => ({\n    context,\n    duration: undefined,\n    path\n  }));\n\nconst hasSCM = changedFilesInfo => {\n  const {repos} = changedFilesInfo; // no SCM (git/hg/...) is found in any of the roots.\n\n  const noSCM = Object.values(repos).every(scm => scm.size === 0);\n  return !noSCM;\n};\n\nclass SearchSource {\n  constructor(context) {\n    _defineProperty(this, '_context', void 0);\n\n    _defineProperty(this, '_dependencyResolver', void 0);\n\n    _defineProperty(this, '_testPathCases', []);\n\n    const {config} = context;\n    this._context = context;\n    this._dependencyResolver = null;\n    const rootPattern = new RegExp(\n      config.roots\n        .map(dir => (0, _jestRegexUtil().escapePathForRegex)(dir + path().sep))\n        .join('|')\n    );\n\n    this._testPathCases.push({\n      isMatch: path => rootPattern.test(path),\n      stat: 'roots'\n    });\n\n    if (config.testMatch.length) {\n      this._testPathCases.push({\n        isMatch: (0, _jestUtil().globsToMatcher)(config.testMatch),\n        stat: 'testMatch'\n      });\n    }\n\n    if (config.testPathIgnorePatterns.length) {\n      const testIgnorePatternsRegex = new RegExp(\n        config.testPathIgnorePatterns.join('|')\n      );\n\n      this._testPathCases.push({\n        isMatch: path => !testIgnorePatternsRegex.test(path),\n        stat: 'testPathIgnorePatterns'\n      });\n    }\n\n    if (config.testRegex.length) {\n      this._testPathCases.push({\n        isMatch: regexToMatcher(config.testRegex),\n        stat: 'testRegex'\n      });\n    }\n  }\n\n  _getOrBuildDependencyResolver() {\n    if (!this._dependencyResolver) {\n      this._dependencyResolver = new (_jestResolveDependencies().default)(\n        this._context.resolver,\n        this._context.hasteFS,\n        (0, _jestSnapshot().buildSnapshotResolver)(this._context.config)\n      );\n    }\n\n    return this._dependencyResolver;\n  }\n\n  _filterTestPathsWithStats(allPaths, testPathPattern) {\n    const data = {\n      stats: {\n        roots: 0,\n        testMatch: 0,\n        testPathIgnorePatterns: 0,\n        testRegex: 0\n      },\n      tests: [],\n      total: allPaths.length\n    };\n    const testCases = Array.from(this._testPathCases); // clone\n\n    if (testPathPattern) {\n      const regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);\n      testCases.push({\n        isMatch: path => regex.test(path),\n        stat: 'testPathPattern'\n      });\n      data.stats.testPathPattern = 0;\n    }\n\n    data.tests = allPaths.filter(test => {\n      let filterResult = true;\n\n      for (const {isMatch, stat} of testCases) {\n        if (isMatch(test.path)) {\n          data.stats[stat]++;\n        } else {\n          filterResult = false;\n        }\n      }\n\n      return filterResult;\n    });\n    return data;\n  }\n\n  _getAllTestPaths(testPathPattern) {\n    return this._filterTestPathsWithStats(\n      toTests(this._context, this._context.hasteFS.getAllFiles()),\n      testPathPattern\n    );\n  }\n\n  isTestFilePath(path) {\n    return this._testPathCases.every(testCase => testCase.isMatch(path));\n  }\n\n  findMatchingTests(testPathPattern) {\n    return this._getAllTestPaths(testPathPattern);\n  }\n\n  findRelatedTests(allPaths, collectCoverage) {\n    const dependencyResolver = this._getOrBuildDependencyResolver();\n\n    if (!collectCoverage) {\n      return {\n        tests: toTests(\n          this._context,\n          dependencyResolver.resolveInverse(\n            allPaths,\n            this.isTestFilePath.bind(this),\n            {\n              skipNodeResolution: this._context.config.skipNodeResolution\n            }\n          )\n        )\n      };\n    }\n\n    const testModulesMap = dependencyResolver.resolveInverseModuleMap(\n      allPaths,\n      this.isTestFilePath.bind(this),\n      {\n        skipNodeResolution: this._context.config.skipNodeResolution\n      }\n    );\n    const allPathsAbsolute = Array.from(allPaths).map(p => path().resolve(p));\n    const collectCoverageFrom = new Set();\n    testModulesMap.forEach(testModule => {\n      if (!testModule.dependencies) {\n        return;\n      }\n\n      testModule.dependencies.forEach(p => {\n        if (!allPathsAbsolute.includes(p)) {\n          return;\n        }\n\n        const filename = (0, _jestConfig().replaceRootDirInPath)(\n          this._context.config.rootDir,\n          p\n        );\n        collectCoverageFrom.add(\n          path().isAbsolute(filename)\n            ? path().relative(this._context.config.rootDir, filename)\n            : filename\n        );\n      });\n    });\n    return {\n      collectCoverageFrom,\n      tests: toTests(\n        this._context,\n        testModulesMap.map(testModule => testModule.file)\n      )\n    };\n  }\n\n  findTestsByPaths(paths) {\n    return {\n      tests: toTests(\n        this._context,\n        paths\n          .map(p => path().resolve(this._context.config.cwd, p))\n          .filter(this.isTestFilePath.bind(this))\n      )\n    };\n  }\n\n  findRelatedTestsFromPattern(paths, collectCoverage) {\n    if (Array.isArray(paths) && paths.length) {\n      const resolvedPaths = paths.map(p =>\n        path().resolve(this._context.config.cwd, p)\n      );\n      return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);\n    }\n\n    return {\n      tests: []\n    };\n  }\n\n  findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {\n    if (!hasSCM(changedFilesInfo)) {\n      return {\n        noSCM: true,\n        tests: []\n      };\n    }\n\n    const {changedFiles} = changedFilesInfo;\n    return this.findRelatedTests(changedFiles, collectCoverage);\n  }\n\n  _getTestPaths(globalConfig, changedFiles) {\n    if (globalConfig.onlyChanged) {\n      if (!changedFiles) {\n        throw new Error('Changed files must be set when running with -o.');\n      }\n\n      return this.findTestRelatedToChangedFiles(\n        changedFiles,\n        globalConfig.collectCoverage\n      );\n    }\n\n    let paths = globalConfig.nonFlagArgs;\n\n    if (globalConfig.findRelatedTests && 'win32' === os().platform()) {\n      const allFiles = this._context.hasteFS.getAllFiles();\n\n      const options = {\n        nocase: true,\n        windows: false\n      };\n      paths = paths\n        .map(p => {\n          const relativePath = path()\n            .resolve(this._context.config.cwd, p)\n            .replace(/\\\\/g, '\\\\\\\\');\n          const match = (0, _micromatch().default)(\n            allFiles,\n            relativePath,\n            options\n          );\n          return match[0];\n        })\n        .filter(Boolean);\n    }\n\n    if (globalConfig.runTestsByPath && paths && paths.length) {\n      return this.findTestsByPaths(paths);\n    } else if (globalConfig.findRelatedTests && paths && paths.length) {\n      return this.findRelatedTestsFromPattern(\n        paths,\n        globalConfig.collectCoverage\n      );\n    } else if (globalConfig.testPathPattern != null) {\n      return this.findMatchingTests(globalConfig.testPathPattern);\n    } else {\n      return {\n        tests: []\n      };\n    }\n  }\n\n  async getTestPaths(globalConfig, changedFiles, filter) {\n    const searchResult = this._getTestPaths(globalConfig, changedFiles);\n\n    const filterPath = globalConfig.filter;\n\n    if (filter) {\n      const tests = searchResult.tests;\n      const filterResult = await filter(tests.map(test => test.path));\n\n      if (!Array.isArray(filterResult.filtered)) {\n        throw new Error(\n          `Filter ${filterPath} did not return a valid test list`\n        );\n      }\n\n      const filteredSet = new Set(\n        filterResult.filtered.map(result => result.test)\n      );\n      return {\n        ...searchResult,\n        tests: tests.filter(test => filteredSet.has(test.path))\n      };\n    }\n\n    return searchResult;\n  }\n\n  findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo) {\n    if (!hasSCM(changedFilesInfo)) {\n      return [];\n    }\n\n    const {changedFiles} = changedFilesInfo;\n\n    const dependencyResolver = this._getOrBuildDependencyResolver();\n\n    const relatedSourcesSet = new Set();\n    changedFiles.forEach(filePath => {\n      if (this.isTestFilePath(filePath)) {\n        const sourcePaths = dependencyResolver.resolve(filePath, {\n          skipNodeResolution: this._context.config.skipNodeResolution\n        });\n        sourcePaths.forEach(sourcePath => relatedSourcesSet.add(sourcePath));\n      }\n    });\n    return Array.from(relatedSourcesSet);\n  }\n}\n\nexports.default = SearchSource;\n"]},"metadata":{},"sourceType":"script"}